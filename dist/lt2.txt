이번 시간에 다룰 내용은 알고리즘 성능 평가입니다. 어떤 알고리즘이 있을 때 그 알고리즘의 성능을 어떻게 평가할 수 있을까요. 흔히 알고리즘의 성능을 평가하기 위해서 복잡도의 개념이 사용되는데요. 엄밀히 말하면 이 복잡도는 계산 복잡도 이론에서 나온 것으로 이 내용을 온전히 이해하려면 추가적으로 많은 내용을 공부해야 하는데요. 이번 강의에서는 알고리즘 문제를 풀기 위해서 꼭 알아야 되는 정보 위주로 압축해서 준비를 해보았습니다. 특정한 알고리즘의 성능을 평가하기 위해서 일반적으로 시간 복잡도와 공간 복잡도 이 두 가지를 분석하는데요. 시간 복잡도는 특정한 크기의 입력에 대해서 알고리즘의 수행 시간을 분석하기 위한 목적으로 사용되며 공간 복잡도는 특정한 크기의 입력에 대해서 알고리즘의 메모리 사용량을 분석하기 위한 목적으로 사용됩니다. 만약에 동일한 기능을 수행하는 알고리즘이 있다면 일반적으로 복잡도가 낮을수록 더 좋은 알고리즘이라고 말할 수 있습니다. 이제 여기에서 말하는 복잡도라는 것은 단순히 소스 코드가 복잡하게 보인다와는 다른 개념입니다. 흔히 이제 소스 코드가 굉장히 길고 많은 모듈을 포함하고 있는 경우 되게 알아보기가 어려우니까 코드가 되게 복잡하다 이런 식으로 이제 말을 하곤 하는데요. 이제 그러한 상황에서 단순히 코드가 보기에 복잡하다 아니면 이해하기에 복잡하다와는 다른 의미라고 보시면 되겠습니다. 여기에서 말하는 복잡도는 그 특정한 함수의 성능적인 측면에서의 복잡도를 의미하는 것입니다. 다시 말해서 시간 복잡도가 높다고 하는 것은 수행 시간 측면에서 더 많은 시간이 소요될 수 있다는 것을 의미합니다. 반대로 시간 복잡도가 낮다라고 하는 것은 해당 알고리즘이 더 빠르게 실행될 수가 있다는 거죠. 반대로 공간 복잡도가 높다는 것은 마른 메모리가 필요할 수 있다는 의미가 되는 것입니다. 그렇기 때문에 이제 기능이 동일하다고 한다면 복잡도가 더 낮을수록 좋은 알고리즘이라고 분석할 수 있습니다. 그렇다면 그러한 복잡도는 구체적으로 어떠한 방식으로 표기할 수 있을까요. 이때 바로 비고 표기법이 효과적으로 사용될 수 있습니다. 비고 표기법이란 가장 빠르게 증가하는 항만을 고려하는 표기법이라고 할 수 있습니다. 사실 비고 표기법도 그 엄밀한 정의를 이해하기 위해서는 계산 복잡도 이론에 대해서 더욱 자세하게 찾아보아야 되는데요. 다만 일반적으로 알고리즘 문제를 푸는 입장에서는 비고 표기법이란 가장 빠르게 증가하는 항만을 고려하는구나 정도만 기억하셔도 문제의 요구 사항을 분석하는 데에는 큰 어려움이 없습니다. 다시 말해 비보 표기법은 가장 빠르게 증가하는 항만을 고려하기 때문에 함수의 상한만을 나타내게 된다는 점이 특징인데요. 예를 들어서 어떠한 함수 혹은 알고리즘에 그 연산 횟수가 3 곱하기 n 3제곱 더하기 5 곱하기 n 제곱 더하기 100만이라고 한번 해볼게요 이때 이것을 비고 표기법으로 나타내고자 한다면 차 수가 가장 큰 항만 남기기 때문에 oln 세제곱이라고 표현할 수 있습니다. 또한 이때 추가적으로 개수는 무시해 주는데요. 지금 보시면은 3 곱하기 n세제곱인데 앞에 붙어 있는 3은 그냥 제거하고 간단히 n 세 제곱이라고 적은 걸 확인할 수 있습니다. 이제 비교 표기법의 개념은 극한의 개념으로 생각해 보시면 더욱더 쉽게 이해할 수 있는데요. 한번 이 n이 엄청 큰 수라고 한번 가정해 볼게요 이 n이 만약에 100만 1억 이런 식으로 굉장히 큰 수가 된다고 하면 저 3n세제곱을 제외한 나머지 향들은 사실상 굉장히 작은 수가 될 것입니다. 그렇기 때문에 n이 굉장히 큰 값이 될 수 있다고 가정을 했을 때 이 함수의 상한만을 고려한다고 하더라도 충분히 그 함수의 성능이 어느 정도가 나올지를 가늠해볼 수가 있는 것입니다. 그래서 실제로 알고리즘은 상수 시간 로그 시간 선형 시간 등으로 표기법을 붙여서 해당 알고리즘의 성능을 나타낼 수 있는데요. 이제 성능상으로 더 좋은 것부터 더 안 좋은 것까지 차례대로 나열해 본 것은 다음과 같습니다. 물론 이를 제외하고도 더 많은 복잡도 표기가 존재할 수 있지만 여기 나와 있는 상수 시간 로그 시간 이제 이것들은 굉장히 많이 사용되는 용어이니까 기억해 두시면 좋습니다. 이제 상수 시간이라고 한다면 정말 상수본 즉 몇 번의 연산만 거치면 수행이 완료되는 경우를 의미하는 거고요 이 로그 시간이라고 하는 것은 로그 n에 비례하는 만큼 수행이 된다는 의미입니다. 이제 이어서 데이터의 크기가 n이라고 했을 때 이 o의 n이라고 표기하는 것은 선형 시간을 의미하는 겁니다. 영어로는 리니얼 타임이라고도 말하고요 그리고 이어서 로그 선형 시간 2차 시간 3차 시간 등 더 높은 복잡도도 존재합니다 한번 간단하게 시간 복잡도를 계산해보는 예시를 확인해보도록 할게요 일단 파이썬 문법은 다음 시간부터 본격적으로 다룰 예정이고요 간단하게 파이썬 코드를 가져온 건데요. 아직 파이썬 문법을 잘 모르시는 분들은 그냥 이런 식으로 복잡도를 분석할 수 있구나 정도만 기억해 두셔도 괜찮습니다. 간단하게 n개의 데이터가 존재할 때 그 데이터를 모두 더한 값을 구하는 프로그램의 예제는 다음과 같은데요. 먼저 이 aray 변수에다가 3 5 1 2 4 이렇게 총 5개의 변수가 포함되어 있는 리스트 객체를 할당해 줍니다. 이제 이 서머리의 값은 처음에 0으로 초기화를 해주고요 이제 모든 데이터를 하나씩 확인하면서 그 값을 서머리에 더해줍니다. 그다음 마지막으로 결과를 출력하는 걸 확인할 수 있는데요. 이제 이 프로그램의 수행 시간은 데이터의 개수인 n에 비례할 것임을 예측할 수가 있습니다. 왜냐하면 모든 데이터를 하나씩 확인하며 합계를 계산하기 때문인데요. 이제 이 경우 데이터를 한 개씩 다 확인을 해야 되기 때문에 총 데이터의 개수만큼 이 서머리 변수의 값이 더해지겠죠. 그렇기 때문에 수행 시간은 데이터의 개수인 n에 비례할 것임을 예측할 수가 있는 것입니다. 지금은 n이 5밖에 안 되지만 만약에 이 n이 100만 1억 이런 식으로 커진다고 하면 그 데이터 베이스 n에 비례하는 만큼 선형적으로 수행 시간이 늘어나게 되겠죠. 또한 확인해 보시면 처음에 이렇게 서머리에다가 0을 대입하거나 그리고 서머리 값을 출력하거나 이런 식으로 다양한 명령어들이 사용된 걸 확인할 수 있어요. 다만 이제 n이 커짐에 따라서 영향을 받는 부분은 바로 모든 데이터를 하나씩 확인하며 합계를 구하는 부분이라고 할 수 있겠죠. 그렇기 때문에 n 값이 증가함에 따라서 바로 이 부분이 영향을 받게 되고 데이터의 개수 n이 많이 커지게 되면 사실 이 부분을 제외한 다른 부분은 사실상 없는 것과 마찬가지로 전체 프로그램의 성능에 많은 영향을 미치지는 않을 것입니다. 이제 한번 다른 예제 또한 확인해 보도록 할게요 이제 다음 예제는 이중 반복문을 이용하는 프로그램 예제인데요. 확인해 보시면 마찬가지로 5개의 데이터가 차례대로 담겨서 리스트 형태로 이 aa이라는 이름의 변수에 담기는 걸 확인할 수 있고요 이제 이렇게 아래쪽에 이중 포문에서 이 변수 아이가 하나씩 어레이의 데이터를 순회할 때마다 매번 또 마찬가지로 제가 이 어레이에 데이터를 하나씩 수매하는 걸 확인할 수 있습니다. 이제 그렇기 때문에 이중 반복문이라는 점에서 간단히 계산을 해보시면 이렇게 아이 곱하기 제가 구해지는 횟수는 총 25회라고 할 수 있습니다. 즉 5 곱하기 5 즉 5의 제곱이라고 말할 수가 있는 것입니다. 즉 그렇기 때문에 이 프로그램의 시간 복잡도는 비교 표기법 n제곱이라고 말할 수 있습니다. 이제 이 프로그램 또한 마찬가지로 이 n의 값이 커짐에 따라서 i와 j가 곱해지는 이 연산이 n 제곱에 비례하는 만큼 많아지게 되겠죠. 그렇기 때문에 이제 이 프로그램의 시간 복잡도는 5에 n 제곱이라고 말할 수 있으며 다만 이제 여기에서 여러분들이 한 가지 알아두시면 좋은 점은 모든 이중 반복문의 시간 복잡도가 n제곱인 것은 닙니다. 이중 반복문이 수행될 때마다 이중 반복 문 안에서 1도의 함수가 또 호출이 되고 이제 그 함수가 더 많은 시간을 필요로 한다면 당연히 그 함수의 시간 복잡도까지 고려를 해줘야 됩니다. 그렇기 때문에 통상적으로 이렇게 이중 반복물이 사용된다고 한다면 n의 제곱만큼 시간이 소요될 수 있겠구나라고 생각을 하시되 내부적으로 수행되는 코드 또한 확인을 해보시고 시간 복잡도가 늘어나는 부분이 있는지 체크하시는 것이 중요합니다. 그래서 실제로 이제 여러분들이 문제를 푸는 입장에서 반드시 알아둬야 되는 팁에 대해서 설명을 드리겠습니다. 일반적으로 cpu 기반의 개인 컴퓨터나 채점용 컴퓨터에서 연산 횟수가 5억을 넘어가는 경우 시어널을 기준으로 해서 통상 1초 이상의 시간의 소요가 되고요 기본적인 파이썬을 기준으로 해서 통상 5초 이상의 시간이 소요됩니다. 물론 시스템에서 파이파이를 지원하는 경우 때때로 시어너보다도 빠르게 동작하는 경우도 존재합니다. 그렇기 때문에 일반적으로 파이선으로 제출을 하게 되면 시어너보다 조금 더 많은 수행 시간이 소요될 수 있다는 점을 기억하시면 좋고 만약에 채점 서버가 파이파이를 제공한다고 한다면 가능하면 파이파이로 제출하는 것이 더 시간 복잡도 측면에서 유리할 수 있습니다. 물론 이제 파이 파이를 이용한다고 해서 항상 파이선보다 빠르게 동작한다고 보장하지는 않으며 파이선보다 더욱 많은 메모리가 사용될 수 있기 때문에 이러한 점 또한 고려하시면서 실제로 문제 풀이에 임하시는 것이 좋습니다. 그래서 일반적으로는 이 파이썬으로 먼저 제출을 해보신 다음에 알고리즘을 효율적으로 잘 작성했음에도 불구하고 시간 초과 판정을 받는다면 파이파이로 다시 한 번 동일한 코드를 제출해 보시는 것을 추천드립니다. 또 반대로 파이파이로 제출을 했을 때 시간 초과 혹은 메모리 초과가 발생하는 경우 파이썬을 이용해서 다시 한 번 제출해 보시는 것도 좋습니다. 그렇다면 실제로 우리가 n 세제곱의 알고리즘을 설계한 경우 이때 n의 값이 5천을 넘는다면 얼마나 시간이 걸릴까요. 이제 뭐 그냥 간단하게 5천을 3번 곱해서 나온 값이라고 할 수 있는 1250억이 그 연산 횟수라고 보시면 되겠는데요. 간단하게 파이썬이 1초에 약 5천만 번 정도의 계산을 처리할 수 있다고 하면 약 2500초 정도가 걸린다고 말할 수 있겠네요. 이제 이런 식으로 어느 정도 수행 시간을 예측해서 알고리즘을 설계하는 것이 중요합니다. 특히 실제로 채점용 서버에서는 이 파이썬이 1초에 약 2천만 번 정도의 연산만 처리할 수 있다고 가정하고 문제에 접하시는 것을 추천드리며 이러한 계산 방식 또한 엄밀히 말하면 이 채점용 서버의 컴퓨터 성능에 따라서 천차만별일 수 있기 때문에 이 점 또한 유의하시고 실제 문제를 푸시는 것을 추천드립니다. 더불어 코딩 테스트 문제에서 수행 시간 제한은 통상 1초에 5초 가량이라는 점에 유의하시는 것이 좋습니다 만약에 문제에서 별도로 시간 제한이 명시되어 있지 않은 경우 대략 5초 정도라고 생각을 하시고 문제를 푸는 것을 추천드립니다. 그래서 우리가 문제를 풀 때는 요구 사항에 따라서 적절한 알고리즘을 설계하는 것이 매우 중요한데요. 일반적으로 대부분의 문제들은 데이터의 개수 n이 주어진다고 하면 그 n의 범위가 어디서부터 어디까지인지 명시를 해주고요 각 데이터의 값 또한 어떤 값 범위로 주어질지 또한 명시가 되어 있습니다. 이제 그렇기 때문에 가장 먼저 그러한 데이터의 조건을 확인해 보신 뒤에 이어서 수능 시간 제한 또한 확인해 주셔야 됩니다. 즉 수능 시간 요구 사항이 어느 정도인지 우리가 제출한 프로그램이 5초 안에 끝나야 되는 건지 아니면 1초 안에 끝나야 되는 건지 등을 문제에서 명시하고 있을 텐데 그 정보를 정확히 캐치하시는 것이 중요합니다 만약에 시간 제한이 1초인 문제를 만났을 때 일반적인 기준은 다음과 같습니다. 파괴성을 기준으로 해서 1초에 2천만 번의 연산을 안정적으로 수행할 수 있다고 가정을 했을 때 a 범위가 500인 경우에는 시간의 복잡도가 5에 n 세제곱인 알고리즘을 설계하면 문제를 풀 수가 있고요 na 범위가 2천인 경우에는 2차 시간으로 동작하는 알고리즘을 설계해야 문제를 풀 수 있을 것입니다. 그리고 애니 범위가 10만일 때는 일반적으로 n 로그 엔 이하로 동작하는 프로그램이 요구되는 거고요 이렇게 n의 범위가 1천만인 경우 이제 이런 경우에는 선형 시간에 동작하는 알고리즘을 설계했을 때 문제를 풀 수 있을 것입니다. 이제 일반적으로 여기 나와 있는 예시는 실제로 제가 문제를 풀 때에도 적용을 하고 있는 방식입니다. 물론 이제 외관적으로 보았을 때는 시간 복잡도가 낮아 보인다고 하더라도 다른 요인에 의해서 불필요하게 시간이 많이 소요돼서 시간 초과 판정을 받는 경우도 있고 굉장히 다양한 케이스가 존재할 수 있기 때문에 이렇게 시간 제한에 따라서 적절한 알고리즘을 설계하는 것은 많은 문제를 접해보시면서 스스로 감을 찾아 나가시는 것이 좋습니다. 그래서 일반적인 알고리즘 문제 해결 과정은 다음과 같이 정리할 수 있습니다. 먼저 지문을 꼼꼼하게 읽고 컴퓨터적 사고를 통해서 문제를 잘게 분해해 보는 거예요. 즉 이제 이 과정에서 뭐가 필요하고 이 과정에서 뭐가 필요하고 이런 것들을 단계별로 잘게 쪼갠 뒤에 문제를 최대한 간결하게 정리를 해보시는 거예요. 문제에 명시되어 있는 요구 사항을 적절히 분석해서 어느 정도 성능으로 동작하는 프로그램을 작성해야 정답 판정을 받을 수 있는지 고민해 보시는 게 중요하고요 이제 이러한 과정에서 또 기본적인 수학적 개념들이 활용될 수 있을 것입니다. 이제 이어서 문제 해결을 위한 핵심 아이디어를 찾고 이제 그 아이디어를 활용해서 실제로 소스 코드를 작성해 문제를 해결할 수 있습니다. 또한 저도 문제를 출제해 본 경험이 있고 다른 문제 출제자 분들과 이야기를 나누었을 때 대부분의 문제를 출제하시는 분들은 핵심 아이디어를 캐치한다면 최대한 간결하게 소스 코드를 작성할 수 있는 형태로 문제를 출제하고자 합니다. 즉 일부러 구현이 어려운 문제를 출제하지 않는 경우 일반적인 문제들은 핵심 아이디어를 잘 캐치한다면 여러분들이 간결하고 깔끔하게 소스 코드를 작성할 수 있다고 볼 수 있고요 애초에 문제에 접근하실 때부터 생각나는 내용을 바로 소스 코드로 옮기기보다 먼저 문제를 온전히 이해하고 어떤 식으로 코드를 작성해 나갈지까지 확실히 정리가 된 다음에 실제 코드를 작성하시는 것을 추천드립니다. 그래서 문제를 처음. 접했을 때 나는 이 문제를 엄청 간결하고 창의적으로 풀 수 있다고 이렇게 스스로한테 확신을 가지시고 문제를 푸시는 게 결과적으로 실수를 줄이고 더욱 빠르게 여러분들의 실력을 들려줄 수 있을 겁니다. 그래서 실제로 파이썬에서는 다음과 같은 소스 코드로 프로그램의 수행 시간을 측정할 수 있는데요. 이렇게 표준 라이브러리에서 이 타임을 불러온 다음에 타임 점 타임 함수를 호출하게 되면 현재 시간이 이렇게 반환이 되는데요. 이제 이것을 스타트 타임 즉 프로그램이 시작되는 부분에 이렇게 값을 담아줄 수 있도록 하고 이어서 프로그램 코드를 중간에 넣어준 뒤에 실제로 프로그램이 종료되었을 때의 그 시간을 측정해서 이 프로그램의 수행 시간을 출력해 볼 수가 있습니다. 이제 수행 시간 측정 코드 또한 여러분들이 문제를 푸는 과정에서 많이 활용해 보시는 걸 추천드리고요 이상으로 이번 시간에는 코딩 테스트를 위한 알고리즘 성능 평가에 대한 내용을 다루어보는 시간을 가져보았습니다.