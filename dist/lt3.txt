이번 시간부터 본격적으로 알고리즘 이론 설명과 문제 풀이를 진행하겠습니다. 첫 번째로 공부할 알고리즘은 그리디 알고리즘입니다. 
그리디 알고리즘은 탐욕법이라고도 말하고요 그리디라는 영단어 자체가 탐욕적인이라는 의미를 가지고 있어서 한국어로는 탐욕법이라고 번역되곤 합니다. 
이러한 그리디 알고리즘은 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미합니다. 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구하는데요. 사실 나중에 배우게 될 크루즈 카워 알고리즘이나 다익스트라 최단 경로와 같이 잘 알려진 알고리즘을 제외하고 일반적으로 그리디 알고리즘이 출제가 되면 해당 문제를 풀기 위한 최소한의 아이디어를 적절히 떠올릴 수 있어야 문제가 풀리도록 출제되는 경우가 많습니다. 그 그리디 해법은 정당성 분석이 매우 중요한데요. 
단순히 현재 상황에서 가장 좋아 보이는 것을 반복적으로 선택을 하는 것만으로도 최적의 해를 보장할 수 있는지를 검토하는 과정이 꼭 필요합니다. 다시 말해 그리디 알고리즘은 탐욕적으로 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미하는 것이며 이러한 방법을 이용했을 때 문제에서 요구하는 최적의 해를 구할 수 있는지 검토하는 과정이 필요합니다 
한번 예시 문제 상황을 확인해 볼게요 다음과 같이 하나의 그래프 그중에서도 트리가 이러한 형태로 구성되어 있다고 가정을 해볼게요 이때 이 루트 노드인 오브 더 출발을 해서 이렇게 다른 노드로 반복적으로 이동하려고 하는데요. 이때 거쳐가는 노드 값의 합을 최대로 만들고 싶습니다. 우리는 이 그래프에서 어떤 식으로 이동하는 게 최적의 해를 보장하는지 
알 수 있죠 애초에 노드 자체가 별로 없으니까 사실 그냥 눈으로 봐도 보이는데요. 이렇게 5 7 이 순서대로 이동하게 되면 노드 값의 합이 21로 가장 큰 경우가 됩니다. 
예를 들어서 5로 갔다가 8로 갔다가 1로 가는 경우 14밖에 얻지 못하는데 이렇게 5로 갔다가 7로 갔다가 구로 가는 경우가 가장 큰 값을 얻을 수 있는 경우라고 할 수 있겠죠. 
그렇다면 이렇게 그래프가 지워졌을 때 우리가 컴퓨터 프로그램을 이용해서 가장 거쳐가는 노드 값의 합이 최대가 되는 경우를 찾고 싶다고 해볼게요 이때 우리는 굉장히 간단하게 프로그램을 작성하는 방법으로 단순히 매 상황에서 즉 현재 위치에서 가장 큰 값만 선택하는 방법을 반복한다면 어떻게 될까요. 예를 들어서 이렇게 시장 노드인 루트 노드에서 출발한다고 했을 때 인접한 노드는 1 10 입니다. 이제 이 경우 단순히 현재 상황에서 가장 큰 값을 가지는 이 10으로 방문을 하게 됩니다. 이후에 마찬가지로 10에서 이동할 수 있는 4와 3 중에서 더 큰 값을 가지는 4로 이동할 수 있겠죠. 다만 이 경우에는 14를 더해서 총 19만큼 합을 얻을 수 있으며 최적의 해인 21보다는 낮은 값임을 알 수 있겠죠. 
그리디 알고리즘은 이처럼 단순히 내 상황에서 가장 큰 값만 고르는 방식이라고 말할 수 있습니다. 앞서 우리가 다루었던 예제에서 볼 수 있듯이 일반적인 상황에서 그리디 알고리즘은 최저 기회를 보장할 수 없을 때가 많습니다. 그래서 실제로 여러분들이 다양한 프로그램을 개발할 때는 그리디 알고리즘을 써도 충분히 최적의 해에 가까운 값을 얻을 수 있거나 혹은 최적의 해를 얻을 수 있을 때 그리디 알고리즘을 사용하는 경우가 많은데요. 다만 코딩 테스트에서는 일반적으로 어떠한 입력이 주어졌을 때 어떠한 출력 값이 나와야 한다는 것을 미리 출제자가 정해놓고 문제를 만드는 경우가 많기 때문에 만약에 그리드 문제가 출제가 된다면 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서 단순히 그리드 알고리즘을 이용해도 이처럼 최적의 해를 얻을 수 있다는 것을 추론할 수 있어야 문제가 풀리도록 출제하는 경우가 많습니다. 즉 흔히 코딩 테스트 문제 중에서 그리디 알고리즘 다른 말로 탐욕법이라고 분류가 되는 문제들은 탐욕법으로 얻은 해가 최적의 해가 되는 경우에 한해서 문제를 출제하는 경우가 많습니다 한번 대표적인 그리디 알고리즘 문제로 거스름 돈 문제를 함께 풀어볼게요 거스름 돈 문제는 어떤 문제일까요. 우리가 정원이라고 해볼게요 이때 카운터에는 거스름 돈으로 사용할 수 있는 500원 100원 50원 그리고 10원짜리 동전이 무한히 존재한다고 가정을 하겠습니다. 이때 손님에게 거슬러주어야 할 돈이 엔원일 때 거슬러주게 되는 동전의 최소 개수를 구하는 게 거스름돈 문제입니다. 단 거슬러줘야 할 돈 애는 항상 10의 배수라서 거슬러주지 못하는 경우는 없다고 합니다. 이제 이때 이 문제는 어떻게 해결할 수 있을까요. 이 거스름돈 문제 해결 아이디어는 굉장히 간단합니다. 이 거스름돈 문제는 그리드 알고리즘을 설명하기 위해 자주 등장하는 문제 예시로서 문제 해결 아이디어는 다음과 같습니다. 최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐 단위부터 돈을 거슬러주면 됩니다. 예를 들어서 n원을 거슬러줘야 할 때 가장 먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러주고 이후에 100원 50원 10원짜리 동전을 차례대로 확인하면서 각각의 동전에 대해서 거슬러 줄 수 있을 만큼 거슬러주면 됩니다 한번 거슬러줘야 할 돈이 1260원일 때를 예시로 확인해 볼게요 먼저 점원이 무한히 많은 동전을 가지고 있다고 가정합니다. 단 원래대로라면 이 점원이 500원 100원 50원 10원짜리 동전을 무수히 많이 가지고 있는 것처럼 그림을 그려야 하지만 일단 이해를 돕고자 이렇게 거슬러줘야 하는 동전의 개수만큼 시각적으로 표현했습니다. 먼저 이렇게 손님은 아무것도 없는 상태고요 이제 1260원 이게 영원히 될 때까지 500원짜리부터 거슬러주는 거예요. 그럼 먼저 500원에 대해서 거슬러주게 되면 500원짜리 2개를 거슬러줄 수 있겠죠. 
이제 이어서 100원짜리 또한 거슬러주고 그리고 50원짜리 또한 거슬러주고 남은 10원에 대해서 마찬가지로 10원짜리로 거슬러주면 됩니다. 결과적으로 이렇게 총 6개의 동전으로 1260원을 거슬러 줄 수 있었습니다. 그렇다면 이렇게 단순히 가장 큰 화폐부터 거슬러주는 것으로 최적의 해를 보장할 수 있는 이유는 무엇일까요. 바로 그 정당성 분석이 중요한데요. 가장 큰 화폐 단위부터 돈을 거슬러주는 것이 최적의 해를 보장하는 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이기 때문입니다. 다시 말해서 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문입니다. 만약에 우리가 800원을 거슬러줘야 하는데 화폐 단위가 500원 400원 100원이라면 어떻게 될까요. 우리의 알고리즘에 따르면은 500원짜리 하나 100원짜리 3개를 거슬러주게 돼서 총 4개라는 답이 나오게 되는데요. 사실 최적의 해는 400원짜리 2개를 거슬러주는 2개가 답이라고 할 수 있겠죠. 다시 말해 큰 단위가 작은 단위의 배수가 아니라면 이와 같은 알고리즘을 이용해서 최적의 해를 보장할 수가 없는 겁니다. 지금 500원짜리가 400원짜리의 배수가 아니죠. 그렇기 때문에 이러한 문제가 발생하는 겁니다. 그리드 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이제 이것이 정당한지 검토할 수 있어야 됩니다. 예를 들어서 이러한 문제를 처음 만났을 때 굉장히 다양한 해법이 나올 수 있을 거예요. 예를 들어서 그냥 10원짜리만 이용해서 다 거슬러준다 아니면 랜덤으로 그냥 한 개씩 뽑아서 거슬러준다와 같이 다양한 방법으로 거슬러 줄 수 있다는 걸 생각을 해내고 그렇게 고민을 하다가 직관적으로 그냥 가장 큰 단위부터 거슬러주게 되면 최소한의 개수로 거스름 돈을 줄 수 있지 않을까라는 생각을 떠올리게 되고 이제 그렇게 했을 때에도 최적의 해를 항상 보장할 수 있는지 고민해 보는 게 중요하겠죠. 이제 그러다가 본 문제의 예시에서는 500원 100원 50원 10원 형 항상 큰 단위가 작은 단위의 동전들이 배수 형태가 된다는 것을 이해하게 되고 그렇기 때문에 단순히 큰 단위부터 거슬러주게 되면 문제를 해결할 수 있구나 떠올릴 수 있는 과정이 중요하다고 할 수 있습니다. 화이선으로 해결할 때는 다음과 같이 코드를 작성할 수 있습니다. 먼저 이렇게 거슬러줘야 할 뿐 n이 있다고 했을 때 이제 큰 다리의 앞에부터 작은 다리의 앞에를 이렇게 리스트에 담아줍니다. 이제 각각의 동전을 확인하면서 이 카운트 즉 결괏값에다가 이 n을 코인으로 나눈 몫을 담습니다. 즉 현재 남아 있는 돈을 현재의 동전으로 최대한 많이 거슬러 줄 수 있도록 하는 거고 그 거스름 돈의 개수를 더해주는 거예요. 이후에 남은 돈은 이 코인보다 즉 해당 화폐 단위보다 더 작아져야 되기 때문에 이 n을 코인으로 나는 나머지 값이 될 수 있도록 합니다. 다시 말해 처음에 이렇게 n이 1260원일 때 500원으로 거슬러주게 되면 두 번 만큼 거슬러줄 수 있게 되고 거슬러준 다음에 260원이 남는 겁니다. 다시 마찬가지로 260원을 이번에는 100원짜리로 나눠주면 되는 거겠죠. 그래서 100원짜리로 2개 나눠줄 수 있고 마찬가지로 260을 200으로 나눈 나머지인 60이 이제 이러한 과정을 반복하게 되면 전체 몇 개의 동전으로 거슬러 줄 수 있는지를 계산할 수 있습니다. 이제 이러한 거스름돈 문제의 풀이 방법을 분석해 보겠습니다. 우리의 알고리즘은 화폐의 종류가 k라고 할 때 소스 코드의 시간 복잡도는 o의 k입니다. 즉 화폐의 종류만큼만 반복을 수행하면 답을 도출할 수가 있다는 거죠. 다시 한 번 코드를 확인해 보시면 이 반복문은 화폐의 종류만큼 반복이 수행됩니다. 
그렇기 때문에 이 소스 코드의 시간 복잡도는 이 화폐의 개수라고 할 수 있겠고요 그렇기 때문에 이 알고리즘의 시간 복잡도는 금액 자체와는 무관하며 공전의 총 종류에만 영향을 받는다는 점이 특징입니다. 이어서 본 책은 기본적으로 파이썬 코드를 제공하고 파이썬 문법을 활용하여 문제를 효과적으로 푸는 방법에 대해서 책에서 다루고 있지만 기본적으로 시 자바 소스 코드 또한 기터브에서 제공을 하고 있어요. 그래서 추가적으로 시뿔 뿔과 자바 코드에 대한 설명 가능하면 문제마다 간단하게라도 넣고자 하는데요. 시볼 코드부터 확인해 보겠습니다. 먼저 시에서는 표준 라이브러리를 불러오기 위한 헤더 파일 추가 구분을 넣어주고요 마찬가지로 정수형 변어로 이 na 값에 1260을 넣어주고요 이 카운트 값은 즉 결과값은 처음에 0으로 초개화합니다. 기본적으로 10에서는 이렇게 전업 변수로 초기화된 값은 자동으로 0이라는 값을 가지고 있어요. 이어서 전체의 동전의 종류 차례대로 명시를 해주는데요. 배열에다가 500 150 10 총 4개의 값을 차례대로 담습니다. 이제 이어서 마찬가지로 반복문을 확인할 수 있는데요. 매번 현재의 그 동전을 확인한 다음에 남아 있는 돈을 현재의 동전으로 남은 몫을 이 프로그램 결과값에 더해줍니다. 해당 동전에 대해서 거슬러주는 게 끝나면 남은 금액 또한 해당 동전으로 나눈 나머지 값이 될 수 있도록 남은 금액을 줄여줍니다. 
이제 이러한 과정을 화폐의 단위 개수만큼 반복하게 되면 결과적으로 거슬러줘야 되는 최소 동전의 개수가 출력됩니다. 마찬가지로 자바 소스 코드 또한 확인할 수 있는데요. 기본적으로 11분에서의 코드와 동일한 로직을 가지고 있는 걸 확인할 수 있습니다. 일반적으로 문자 프리 사이트마다 조금씩 다를 수 있는데 자바 소스 코드를 제출할 때는 이 클래스 명을 메인이라고 설정할 수 있도록 요구하는 경우가 많습니다.