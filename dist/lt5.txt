이어서 구현 문제 유형에 대해서 알아보겠습니다. 특히 시뮬레이션과 완전 탐색에 초점을 맞추어서 알아보겠습니다. 구현이란 기본적으로 머릿속에 있는 어떤 알고리즘과 생각을 소스 코드로 바꾸는 과정입니다. 즉 아무리 알고리즘을 잘 세워도 실제로 코드로 작성해서 프로그램으로 만들지 않으면 그 알고리즘이 실제로 동작하지 않겠죠. 그렇기 때문에 우리가 알고리즘 문제를 푸는 과정에서 이러한 구현은 반드시 필요한 과정입니다. 그래서 이러한 측면에서 보았을 때 사실 우리가 어떤 알고리즘 문제를 푼다고 하더라도 결국에는 토스 코드로 구현을 해야 되기 때문에 사실 모든 문제가 다 구현 유형의 문제라고 할 수 있겠죠. 하지만 일반적으로 우리가 특정 문제때를 구현 유형의 문제라고 부를 때는 대개 문제에서 요구하는 내용이 구현에 초점이 맞춰져 있거나 구현이 어려운 문제를 의미합니다. 그래서 흔히 알고리즘 대회나 코딩 테스트에서 구현 유형의 문제란 무엇을 의미할까요. 흔히 구현 유형의 문제는 풀리를 떠올리는 것은 쉽지만 소스 코드로 옮기기 어려운 문제를 지칭할 때 구현 문제라고 말합니다. 이러한 구현 유형의 예시는 다음과 같은 것들이 있는데요. 먼저 알고리즘은 간단하지만 코드가 지나칠 만큼 길어지는 문제가 이에 해당합니다. 사실 이러한 문제는 자기가 사용하는 프로그래밍 언어에 따라서도 달라질 수 있는데요. 예를 들어 자바를 기준으로 해서 클래스도 만들어야 되고 별도의 인터페이스를 상속도 받아서 구현을 해야 되는 문제가 파이썬에서는 기본적으로 제공하는 자료형과 내장 함수만을 이용해서 간단히 구현할 수도 있습니다. 그래서 어떤 프로그래밍 언어에서는 구현이 많이 어렵지만 특정 언어에서는 구현이 쉬울 수도 있기 때문에 이러한 문제는 프로그래밍 언어에 따라서 조금씩 유형이 달라질 수도 있다는 점 감안해 주세요. 또 실수 연산을 다루면서 특정 석수점 자리까지 출력해야 되는 문제도 문법적으로 특정 프로그래밍 언어로 구현할 수 있는 방법을 알고 있어야 되기 때문에 이러한 유형 또한 구현 문제 유형이라고 부르고 그리고 대표적으로 문자열을 특정 기준에 따라서 끊어 처리해야 하는 문제 등도 구현 문제 유형에 속합니다. 특히 문자열 처리 같은 경우는 파이썬이 다른 언어에 비해서 상대적으로 사용하기가 편한 편입니다. 그래서 실제로 문자열을 처리하는 구현 문제 중에서 낮은 난이도의 문제들이 1번 혹은 2번에 많이 출제가 되곤 합니다. 그리고 혹은 적절한 라이브러리를 찾아서 사용할 때 매우 쉽게 풀리는 문제들이 존재하는데요. 이제 이런 경우 또한 우리가 미리 어떤 적절한 라이브러리의 사용 방법을 알고 있어야 되고 그러한 방법을 잘 알고 있지 못한다면 우리가 아주 방대한 양을 구현을 해야 되기 때문에 난이도가 확 높아지는 문제도 존재합니다. 대표적으로 모든 순열과 모든 조합을 찾는 문제 등이 그렇습니다. 파이썬에서는 이터 툴스 라이브러리를 이용해서 모든 순혈이나 조합을 찾을 때 매우 간결한 코드로 프로그램을 작성할 수 있는데요. 이게 대표적인 예시라고 할 수 있습니다. 이러한 구현 유형의 문제들은 사실 많은 연습이 꼭 필요한 분야이기도 합니다. 여러분들이 많은 코드를 작성하고 많은 라이브러리들이 존재한다는 것을 미리 공부를 해놓으면 당연히 다양한 구현 문제가 나왔을 때 당황하지 않고 대응할 수 있겠죠. 또한 본 교재에서는 시뮬레이션과 완전 탐색을 중점으로 해서 이 구현 유형의 파트를 다루고 있습니다. 일반적으로 많은 기업 코딩 테스트 문제에서는 2차원 공간에서의 처리를 요구합니다. 실제로 우리가 2d 게임을 개발하거나 할 때는 이런 2차원 공간을 행렬과 같은 형태로 표현해서 내부적으로 처리하거나 하는데요. 실제 코딩 테스트에서도 다양한 시뮬레이션 문제에서 이런 2차원 공간을 가정하는 상황이 많이 등장합니다. 예를 들어서 2차원 맵의 한 좌표에 존재하는 캐릭터가 반복적으로 어떤 위치로 이동한다와 같은 문제 상황이 많이 등장하는데요. 이제 그러한 문제를 적절히 해결하기 위해서 행렬에 대한 개념 이해가 필요합니다. 행렬이란 2차원 데이터를 일종의 표와 같은 형태로 쉽게 나타내줄 수 있도록 하는 수학 개념 중 하나인데요. 흔히 프로그래밍 언어에서 2차원 배열이라고 부르는 것과 사실상 동일합니다. 파이썬에서는 2차원 리스트가 되겠죠. 행렬에서는 이렇게 가장 왼쪽 위에 있는 원소가 첫 번째 원소고요 이 세로축을 행이라고 하고 가로축을 열이라고 합니다. 그래서 이렇게 왼쪽 위부터 차례대로 오른쪽으로 이동하면 열 위치가 증가하는 거라고 볼 수 있고요 이렇게 아래쪽으로 이동할수록 그 행 인덱스가 증가한다고 볼 수 있습니다. 그렇기 때문에 실제로 여러분들이 많은 완전 탐색 혹은 시뮬레이션 문제를 접할 때 문제에서 정의하는 내용을 확인해 보시면 가장 왼쪽 위 위치를 이렇게 0 컴마 0이라고 부르는 경우가 많습니다. 이제 이것은 여러분들이 중고등학교 때 공부하는 일반적인 유클리드 좌표계에서의 x축과 y축에 대한 개념과 조금 다를 수 있기 때문에 이렇게 왼쪽 위가 일반적으로 행렬에서 첫 번째 원수구나라는 점을 기억해 두시면 좋습니다. 또한 시뮬레이션 문제 같은 경우는 특정한 캐릭터나 어떤 사물 등이 특정 위치에 존재했다가 이제 여기에서 상하좌우로 이동할 수 있다 등으로 문제 상황이 정리되는 경우가 많은데요. 이제 그러한 문제를 해결하기 위해서 방향 벡터가 자주 사용됩니다. 확인해 보시면 만약에 특정 위치에서 위쪽으로 이동한다고 치면 행 데이터가 1만큼 감소하는 걸 확인할 수 있습니다. 그래서 이렇게 이 차원 맵의 형태를 행렬과 동일하게 본다고 했을 때 동북 선함은 차례대로 이렇게 각각의 방향 벡터를 정의할 수 있습니다. 여기에서 이 x는 이 세로축을 의미하는 거고요 즉 행을 의미하는 거고 이 y는 이 가로축 즉 열을 의미한다고 보시면 됩니다. 그래서 동쪽 같은 경우는 행을 기준으로 가만히 있고 이 열을 기준으로 해서 1만큼 증가하는 것이기 때문에 이렇게 오른쪽으로 이동하는 거라고 볼 수 있고요 그다음에 북쪽 같은 경우는 이 행을 기준으로 해서 1만큼 빼주기 때문에 이렇게 위쪽으로 가는 거라고 볼 수 있고요 마찬가지로 서쪽은 이렇게 행은 그대로 있고 열만 1만큼 빼준다고 볼 수 있고 이 남쪽 같은 경우는 아래쪽으로 가는 것이기 때문에 마찬가지로 행을 1만큼 증가시킨 것과 동일할 겁니다. 그래서 이런 식으로 실제로 특정 위치가 x랑 y 좌표로 정해져 있다고 했을 때 우리가 다음 위치를 확인할 때 이렇게 x에다가는 이 dx를 더해 줌으로써 행 방향으로는 어떤 방향으로 이동할 건지 설정할 수 있고 마찬가지로 열 또한 이렇게 dy를 이용해서 어떤 방향으로 이동할 건지를 설정할 수 있습니다. 그래서 이렇게 상하좌우 위치를 다 살펴보면서 출력하고자 할 때 바로 이러한 로직이 사용됩니다. 물론 현재 코드에서는 동북 서남 순서대로 그다음 위치가 출력이 되겠네요. 그래서 실제로 특히 코딩 테스트 환경에서는 2차원 공간에서의 방향 벡터가 많이 사용되고요 이러한 각각의 방향에 따라서 실제로 어떤 위치에서 다른 위치로 이동시키는 방식으로 로직을 설계하는 경우가 많습니다. 그래서 이렇게 dx와 디와는 차례대로 다이렉션 x 다이렉션 y와 같은 형태로 어떤 방향성을 명시해 주기 위해서 배열 혹은 리스트와 같은 형태로 사용됩니다. 그래서 간단하게 대표적인 구현 문제로 상하좌우 문제를 확인해보고 마치도록 할게요 그래서 이번 시간에는 가장 대표적인 구현 문제 그중에서도 시뮬레이션 유형으로 이상하저우 문제를 확인해 보겠습니다. 상하좌우 문제는 이렇게 n바이 n 크기의 정사각형 공간 위에 여행가 a가 서 있다고 가정하고 있습니다. 그래서 이 공간은 1과 1 크기의 정사각형으로 나누어 떨어진다고 설명을 하고 있고요 이때 가장 왼쪽 위 자표는 1커마일이라고 합니다. 물론 실제로 우리가 2차원 리스트를 이용해서 이러한 행렬 혹은 2차원 공간을 표시할 때는 인덱스는 0 커머 0부터 출발합니다. 하지만 이렇게 문제에서 1컵 마일부터 출발한다고 하면 가장 첫 번째 인덱스는 그냥 사용하지 않는 방식을 이용할 수 있고 혹은 그렇지 않다면 이렇게 1컵마 1을 실제 우리 소스 코드 상에서는 0 컵마 0인 것처럼 처리하도록 만들어서 코드를 작성할 수도 있습니다. 아무튼 그래서 본 문제에서는 가장 왼쪽 위가 1컴 1이고 가장 오른쪽 아래가 엔마 1이라고 합니다. 이때 여행과 a는 상하 좌우로 이동할 수 있으며 맨 처음에는 1 컴마 1에 즉 가장 왼쪽 위 존재한다고 설명하고 있네요. 그다음 이제 우리는 하나의 계획서를 확인해서 이 여행가를 이동시키면 되는 건데요. 이렇게 계획서에는 lal ud 중에서 하나의 문자가 반복적으로 적혀 있다고 해요. 그래서 이렇게 차례대로 left right 업 다운의 의미를 가지고 있다고 합니다. 그래서 여행과 a를 계획서에 따라서 이동을 시킬 건데 전체 n과 n 크기의 공간을 벗어나는 움직임은 무시된다고 합니다. 예를 들어서 한번 이러한 계획서를 확인해 볼게요 이때는 얼얼얼 udd죠 그래서 이렇게 오른쪽으로 3칸 이동합니다. 그다음에 이제 u를 만났으니까 이렇게 위쪽으로 이동을 해야 되는데 위쪽으로 가면 공간을 벗어나기 때문에 이 u는 그냥 무시하고 이제 이어서 이렇게 다운 다운 해가지고 아래쪽으로 두 칸을 이동해서 결과적으로 3콤마 4의 위치에 도달을 하게 됩니다. 그래서 정답으로 3컵만 4를 출력하면 정답 판정을 받을 수 있겠죠. 그래서 이 문제는 시간 제한이 2초고요 이렇게 메모리 제안은 128m라고 합니다. 이때 이렇게 n은 최대 100이기 때문에 100바 100짜리 2차원 리스트를 만들면 총 1만 개만큼의 위치가 존재한다고 할 수 있겠네요. 그다음에 이제 여행과 a가 이동할 계획서는 최대 100개까지 각각의 이동으로 구성된다고 합니다. 이 문제는 어떻게 풀 수 있을까요. 한번 각자 코드를 작성해 보세요. 이어서 이 문제의 해설을 진행하겠습니다. 이 문제는 그냥 간단히 요구 사항대로 충실히 구현하면 되는 문제입니다. 1년의 명령에 따라서 어떠한 캐릭터와 같은 개체를 차례대로 이동시킨다는 점에서 시뮬레이션 유형의 문제라고 볼 수 있으며 구현이 중요한 대표적인 문제 유형으로 분류할 수 있습니다. 다만 실제로 우리가 다양한 알고리즘 교재나 문제 풀이 사이트에서 문제를 접할 때 이러한 문제 유형을 서로 다르게 일컫을 수도 있습니다. 그래서 그냥 단순하게 구현 유형이라고 부를 수도 있고 단순하게 그냥 시뮬레이션 혹은 완전 탐색이라고 적어놓을 수도 있습니다. 그렇기 때문에 시뮬레이션 유형 구현 유형 완전 탐색 유형은 서로 유사한 점이 많다는 정도만 기억하시면 좋을 것 같습니다. 본 교재에서는 이 완전 탐색 유형과 시뮬레이션 유형을 구현 유형으로 묶어서 다루고 있습니다. 그래서 실제로 이러한 로직을 먼저 파일선으로 작성하면 다음과 같습니다. 이렇게 현재 위치를 의미하는 x랑 y 변수가 사용되고요 이제 이렇게 방향 팩터를 위해서 즉 lrud로 이동하는 그 각각의 방향을 명시해 주기 위해서 이렇게 dx랑 dy를 사용하는 걸 확인할 수 있고요 이동 가능한 문자로 에어 rud만 존재하니까 이것들을 각각 리스트에 담을 수 있도록 합니다. 계획서에 적혀 있는 이동 계획을 하나씩 확인하면서 이동 후 좌표를 설정할 수 있도록 합니다. 즉 현재의 이동 계획이 이 무브 타입스 중에서 어떤 건지 확인을 해서 그 무브 타입스에 맞는 다음 위치 값을 이 dx랑 dy 값을 찾아서 이 다음 위치 값을 설정한 것을 확인할 수 있습니다. 여기에서 파이썬 같은 경우는 이렇게 이 nx랑 ny가 사용되기 전에 nx랑 ny를 초기화하지 않아도 바로 옆에 값을 대입해서 이 반복문 바깥쪽에 있는 이 부분에서 이를 바로 참조할 수 있습니다. 이렇게 nx랑 ny를 초기화하는 부분은 제외하고 바로 이렇게 nx랑 ny 값을 이동 방향에 따라서 여기에서 초기화할 수 있도록 하고 이제 그렇게 찾아진 nx에 따라서 즉 다음 위치에 따라서 공간을 벗어나지 않는다면 실제로 이동할 수 있도록 만드는 로직이 사용된 걸 확인할 수 있습니다. 그래서 결과적으로 계획서의 모든 이동 계획을 하나씩 확인하면서 이동을 수행한 결과를 출력하면 그게 정답이 됩니다. 마찬가지로 c 플러스 플러스에서도 동일한 로직으로 작성할 수 있습니다.