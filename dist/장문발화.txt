다시 말해 이러한 우선순위 q는 데이터를 우선순위에 따라 처리하고 싶을 때 사용할 수 있는 자료 구조입니다. 가장 대표적인 예시는 어떠한 물건 데이터를 자료 구조에 넣었다가 가치가 높은 물건부터 차례대로 꺼내서 확인하고 싶을 때 우리는 우선순위 큐에 각각의 물건 정보를 가치 데이터와 함께 우선순위 큐에 넣었다가 우선순위 q에서 데이터를 꺼낼 때는 항상 가치가 높은 값부터 차례대로 나올 수 있도록 그렇게 만들 수 있겠죠. 따라서 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료 구조 데이터를 우선순위에 따라 처리하고 싶을 때 사용한다 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 재료 고조 이런 데이터를 자료 구조에 넣었다가 따라서 가장 기본적인 자료 구조인 가치가 높은 물건부터 꺼내 확인해야 하는 경우 스텝과 q 그리고 우선순위 뷰를 비교한 것은 바로 다음이 표와 같은데요. 이때 각각의 자료 구조의 특징을 확인해 보시면 추출되는 데이터는 이 스택의 경우에는 가장 나중에 들어온 데이터가 먼저 나가게 되고요 그리고 q는 가장 먼저 들어온 데이터가 먼저 나가게 됩니다. 그래서 이 q 같은 경우는 흔히 공평한 자료 구조라고 비유적으로 표현한다고 했었죠. 그리고 마지막으로 우선순위 q는 가장 우선순위가 높은 데이터부터 차례대로 뽑는 방식으로 동작하는 자료 구조입니다. 그렇다면 이러한 우선순위 큐를 우리가 실제로 구현하고자 할 때 어떤 방법을 이용할 수 있을까요. 첫 번째는 단순히 리스트를 이용하는 방식입니다. 이때 리스트에 그냥 차례대로 데이터를 뒤쪽에 쭉 연달아 넣은 다음에 데이터를 꺼낼 때는 이 리스트에서 각각의 데이터를 확인한 뒤에 가장 값이 큰 데이터를 뽑아서 추출하면 되겠죠. 또한 1 자료 구조를 이용해서 구현할 수 있는데요. 1 자료 구조를 이용한 구현 방식에 대해서는 조금 이따가 자세하게 설명드릴게요 그래서 일단 결과를 요약해서 보여드리자면 데이터 개수가 n개일 때 구현 방식 리스트 그다음에 힘에 따라서 시간 복잡도를 비교하면 다음과 같습니다. 리스트의 경우에는 데이터를 삽입할 때 그냥 단순히 뒤쪽에 연달아 넣으면 되기 때문에 시간 복잡도는 1위라고 할 수 있겠고요 다만 데이터를 삭제할 때는 삭제하고자 하는 데이터는 가장 우선순위가 높은 데이터여야 하기 때문에 가장 높은 우선순위를 가지는 데이터를 찾기 위해서 이와 같이 선형적인 탐색 시간이 소요됩니다. 반면에 힙 같은 경우는 데이터를 넣는 것과 빼는 과정에서 모두 최악의 경우에도 시간 복잡도 비고 노테이션 로그 n을 보장할 수 있는 방식으로 동작합니다. 그래서 이러한 팁 같은 경우는 데이터의 삽입과 삭제에 있어서 모두 로그 n에 시간이 소요되기 때문에 그냥 단순히 엔게이 데이터를 힙에 넣었다가 모두 꺼내는 작업만 수행하더라도 그 자체로서 정열이 실행된다는 점이 특징이고요 이때 이 엔게이 데이터를 모두 힙에 넣기 위해서 엘로그 엔의 시간 복잡도가 소요되고 이어서 엔게이 데이터를 다시 히에서 꺼낼 때도 엘로그 n의 복잡도가 소요되기 때문에 결과적으로 비고 표기법에 따라서 시간 복잡도는 5의 엘로그 n이라고 표현할 수 있습니다. 그래서 바로 이와 같이 이러한 시간 복잡도는 병합 정렬과 같은 다른 일반적으로 사용되는 정열 알고리즘과 동일하게 빠른 정열 알고리즘이라고 표현할 수 있겠죠. 그래서 이러한 정열 알고리즘을 우리는 십 정혈이라고 부릅니다. 그렇다면 실제로 힙 자르 구조는 어떤 식으로 구현할 수 있을까요. 십 자르 구조는 완전 이즘트리 자르 구조의 일종입니다. 이때 완전 이젠 트리에 대해서는 조금 이따가 또 설명드릴게요 십은 일종의 트리 자료 구조로서 항상 루트 노드를 제거하는 방식으로 동작합니다. 즉 데이터를 넣을 때는 이렇게 트리에다가 데이터를 넣도록 하고 데이터를 꺼낼 때는 이 루트 노드에 위치한 데이터가 나올 수 있도록 하는 겁니다. 이때 힘은 두 가지로 분류할 수 있는데요. 먼저 채소 힙 즉 미니 힙은 전체 트리에서 루트 로드가 가장 작은 값을 가질 수 있도록 구성된 자료 구조입니다. 그래서 값이 가장 작은 데이터가 우선적으로 제거된다는 점이 특징이고요 오른쪽 그래프가 가장 대표적인 최소 힙 자루 구조의 예시라고 할 수 있는데요. 확인해 보시면 이 3번 노드가 전체 트리에서 가장 작은 값을 가지고 있는 걸 확인할 수 있고요 또한 이렇게 각각의 서브 트리를 확인했을 때에도 이 서브 트리에서 루트 노드가 가장 작은 값을 가지는 걸 확인할 수 있죠 바로 이러한 특징을 가진 게 최소 힙이라고 할 수 있겠고요 만약에 우리가 오음 차선 정렬을 시행한다고 치면 이러한 최소 힙에다가 nda 데이터를 그냥 다 넣은 다음에 꺼내기만 하더라도 오음 차선 정렬된 결과가 출력이 될 겁니다. 이어서 최대 입에 대해서 확인해보겠습니다. 최대 힙은 최소 힙과 반대로 루틴 로드가 가장 큰 값을 지는 방식으로 동작하는 힙 자루 구조입니다. 최대 힙에서는 루틴 로드가 가장 큰 값을 가지기 때문에 값이 큰 데이터가 우선적으로 제거된다는 점이 그 특징입니다. 앞서 언급했듯이 힙은 완전 이젠트리 형식을 따른다고 말씀드렸는데요. 컴플릿 바이너리 틀이라고도 하고요 루트 노드부터 시작해서 왼쪽 다식 노드 그리고 오른쪽 자식 노드 순으로 데이터가 차례대로 들어가는 트리를 의미합니다. 예를 들어 원소의 개수가 1개일 때는 항상 이런 모양이고 원소의 개수가 2개일 때는 항상 이처럼 루트가 있고 이 왼쪽에 두 번째 노드가 들어가는 형식을 따르고요 원소의 개수가 3개일 때는 이런 형태 그리고 4개일 때 바로 이런 형태를 따르는 방식을 완전 이진틀이라고 합니다. 그렇다면 우리가 어떠한 데이터를 힙에 넣었을 때 그 힙 자료 구조가 힙의 성질을 가지도록 만들려면 어떻게 해야 될까요. 이때 최소 힙을 구성하는 함수인 민 히피파 함수에 대해서 확인해 보겠습니다. 일반적으로 힙을 구성하기 위한 함수의 이름을 보통 히피 파이라고 이렇게 부르고요 이때 히피 파이는 상향식과 하향식으로 구현할 수 있는데 간단히 상향식에 대해서 확인해 보겠습니다. 실제로 힙에서는 하나의 데이터가 이렇게 들어왔을 때 이 들어온 데이터로부터 부모 쪽으로 거슬러 올라가면서 즉 상향식으로 매번 부모보다 자신의 값이 더 작은 경우에 위치를 바꿀 수 있도록 하는 겁니다. 예를 들어서 이렇게 새로운 데이터인 자가 들어왔을 때 바로 이처럼 최소 힙 성질을 만족하지 않는 경우를 확인할 수 있는데요. 바로 이럴 때 우리가 히피 파일을 수행하게 되면 수행한 결과 바로 다음과 같이 최소 힙 성질을 만족하도록 트리가 구성됩니다. 이제 이후에 다시 이렇게 4번 노드와 3번 노드를 비교해서 만약에 4번 노드가 더 작다면 위치를 교체할 수 있도록 하면 되겠죠. 바로 이러한 방식으로 동작하는 게 히피 파일입니다. 다시 한 번 그림을 통해서 확인해 보시면요. 새로운 원소가 들어왔을 때 바로 이러한 히피 파일을 이용하게 되면 비고 노테이션 로그 n의 시간 복잡도로 성질을 유지할 수 있도록 할 수 있습니다. 이때 기본적으로 십 자료 구조는 완전 이젠트리를 따르기 때문에 균형 잡힌 트리로서 동작한다는 점이 특징입니다. 그렇기 때문에 항상 부모 쪽으로 거슬러 올라가거나 아니면 다시 부모에서 자식으로 내려올 때 최악의 경우에도 로그인 n의 시간 복잡도를 보장할 수 있다는 거죠. 그래서 이와 같이 새롭게 일하는 데이터가 한번 들어왔다고 가정을 해보겠습니다. 이제 이때는 바로 이렇게 이 2가 9보다 작기 때문에 위치를 바꿔주고 다시 이렇게 또 e가 3보다 작기 때문에 또 위치를 바꿔주게 돼서 단 두 번만 거슬러 올라가더라도 이 루트까지 도달할 수 있습니다. 즉 전체 데이터의 개수가 n 개일 때 로그 n의 시간 복잡도록 이 루트까지 히피 파이 함수를 이용해서 확인할 수가 있다는 겁니다. 그래서 결과적으로 이 경우에는 히피 파이를 호출했을 때 바로 오른쪽 그림과 같이 전체 트위가 갱신되는 걸 확인할 수 있습니다. 반대로 힘에서 원소가 제거될 때는 바로 다음과 같이 제거 과정을 진행할 수 있는데요. 원소를 제거할 때는 최악의 경우에도 마찬가지로 시간 복잡도 비고 노테이션 로그 n을 보장할 수 있는데요. 원소를 제거할 때 가장 마지막 로드가 먼저 루트에 위치할 수 있도록 합니다. 그래서 구현 방식의 차이가 있을 수 있지만 단순히 그냥 이 루트 로드와 마지막 로드의 위치를 바꾸는 방식을 사용할 수도 있습니다. 그래서 이와 같이 이 일을 꺼낸 다음에는 가장 마지막 원서가 가장 위쪽에 들어올 수 있도록 하고요 이제 다시 히이 파일을 수행해서 전체 트리가 1 성질을 만족할 수 있도록 만듭니다. 그래서 확인해 보시면 현재 룰트 노드인 9번 노드부터 출발을 해서 매번 자기 자식을 확인해서 더 값이 작은 자식과 현재 루트의 위치를 바꿀 수 있도록 하는 것입니다. 마찬가지로 루트에서부터 가장 아래쪽으로 내려갈 때까지 로그 n의 시간 복잡도를 보장할 수 있습니다. 히피 파일을 수행해서 바로 오른쪽 그림과 같이 다시 힙의 성질이 만족하는 형태로 구성되는 걸 확인할 수 있습니다. 그렇기 때문에 매번 힙에서 원소를 꺼낼 때 혹은 힙의 원소를 넣을 때 모두 로그 n의 시간 독잡도를 보장할 수 있는 것입니다. 일반적으로 우리가 파이썬 십을을 자바 등 다양한 프로그래밍 언어를 이용할 때 표준 라이브러리에서 이러한 힘 자루 구조를 제공하고 있습니다. 파이썬의 경우 이와 같이 힘 라이브러리를 인폴트에서 사용할 수 있고요 간단히 힙 정렬을 구현한 예시는 다음과 같습니다. 리스트나 캐플과 같이 하나의 이터러브라는 객체가 들어왔을 때 단순하게 그냥 이 힙 라이브러리에 푸시 함수를 이용해서 힙에 모든 원소를 다 담을 수 있도록 하고요 이어서 힙에 삽입된 모든 원소를 차례대로 꺼내서 이 리졸트 리스트에 담을 수 있도록 해서 이를 리턴할 수 있도록 합니다. 그래서 결과적으로 힙전계를 수행한 결과를 출력해 보시면 오름 차순 연결된 결과가 출력되는 걸 확인할 수 있습니다. 참고로 프로그래밍 언어마다 기본적으로 제공하는 이 힙 라이브러리가 최소 힙인지 혹은 최대 힙인지는 다를 수 있는데요. 이 파이썬의 경우에는 기본적으로 십 자를 구조는 민힙 형태로 동작합니다. 그래서 오름 차선 정열이 수행되는 걸 확인할 수 있고요 만약 파이썬에서 맥스 십 형태로 동작하는 1 자료 구조가 필요하다면 이 데이터를 넣을 때와 그리고 데이터를 꺼낼 때 이 마이너스를 붙여서 데이터를 꺼내게 되면 맥스 힘으로 동작하도록 만들 수 있습니다. 이어서 시 플러스에서는 바로 다음과 같이 우선순위 q 라이브러리를 사용할 수 있는데요. 마찬가지의 로직으로 하나의 벡터 객체가 있을 때 그 레퍼런스를 참조하도록 해서 하나의 우선순위 q 객체를 만든 뒤에 차례대로 우선순위 q에 넣은 다음에 이어서 모든 데이터를 다시 우선순위 q에서 꺼내도록 만들어서 팁 정렬이 수행된 결과를 출력하도록 만들 수 있는데요. 참고로 1 플러스 플러스에서는 이와 같이 기본적으로 제공하는 우선순위 q 라이브러리가 가장 큰 값이 먼저 나오도록 동작을 하기 때문에 우리가 오른 차선 정렬을 수행한다고 하면 이와 같이 데이터를 넣을 때와 뺄 때 이 마이너스를 붙여서 부호를 반대로 해서 동작하도록 만들면 오음 차선 정렬을 수행할 수 있는 것입니다. 따라서 이와 같이 이번 시간에는 우선순위 q의 개념에 대해서 공부한 뒤에 실제 우선순위 q 라이브러리를 활용해서 간단히 실 정렬을 수행해보는 예제까지 다뤄보는 시간을 가져보았습니다. 이번 시간에는 트리 자료 구조의 기본적인 내용에 대해 알아보겠습니다. 트리는 가계도와 같은 계층적인 구조를 표현할 때 사용할 수 있는 자료 구조입니다. 여기에서 왼쪽 그림은 대표적인 트리 자리 구조의 예시를 보여주고 있는 건데요. 이 위쪽에 뿌리고 이 뿌리에서부터 가지를 치면서 뻗어 나가는 형태로 자료 구조가 구성되어 있는 걸 확인할 수 있습니다. 일반적으로 틀이 자료 구조를 표현할 때는 그 뿌리가 위쪽에 올 수 있도록 합니다. 다시 말해서 현재 그림에서는 이 에이원 노드가 루트 노드로서 더 이상 부모가 없는 최상의 노드라고 할 수 있습니다. 쉽게 말하면 이러한 틀이 자료 구조는 현실 세계에서 계층적인 구조를 표현할 때 사용할 수 있는데요. 가장 대표적인 예시는 가계도입니다. 흔히 단군 신화에 따르면 이 루트 노드는 단군 할아버지라고 할 수 있을 거고요 이와 같이 굉장히 많은 가지를 뻗어나가서 현세에 있는 우리들은 굉장히 아래쪽에 있는 노드에 해당되겠습니다. 그래서 이러한 트리 자료 구조에서 사용되는 용어에 대해서 확인해 보겠습니다. 먼저 롯데 로드란 아까 말씀드렸듯이 부모가 없는 최상의 노드라고 할 수 있고요 단말 노드란 반대로 자식이 없는 노드 즉 가장 아래쪽에 붙어 있는 노드가 단말 노드가 되겠습니다. 따라서 현재 그림에서는 e f 그리고 g가 단말 노디에 해당합니다. 또한 트리의 크기라고 한다면 트리에 포함된 모든 노디의 개수를 흔히 크기라고 합니다. 그리고 각 노드의 깊이란 루트 노드부터의 거리라고 할 수 있는데요. 여기에서 이 에이번 노드의 깊이는 0이 되겠습니다. 그리고 이번 노드 1번 노드의 깊이는 1이 되고요 그리고 디번 노드 이번 노드 에프번 노드의 깊이는 2가 되겠습니다. 그리고 마지막으로 1번 노드의 깊이는 3이 되겠습니다. 그리고 트리의 높이라고 하는 것은 깊이 중에 가장 큰 값을 의미하는데요. 여기에서는 이 지번 노드의 깊이 즉 3이 이 트리의 전체 높이라고 할 수 있습니다. 노라는 각 노드에서 차수라고 하는 것은 각 노드의 자식 방향의 간선 개수를 의미합니다. 예를 들어 1번 노드의 차수는 2가 되겠고요 비번 노드의 차수는 이 비번 노드의 차수는 1 이런 식으로 자식이 몇 개인지 자식 방향으로 현재 자기 노드에서 연결되어 있는 이 자식의 수가 차수가 되겠습니다. 또한 트리 같은 경우는 여러분들이 기억하시면 좋은 특징이 있는데요. 트리의 크기가 n일 때 즉 트리에 포함되어 있는 모두의 개수가 n 개일 때 전체 간선의 개수는 n 마이너스 1개라는 점이 특징입니다. 이어서 이진 탐색 트리에 대해 알아보겠습니다. 이진 탐색 트리란 바이너리 솔치트리라고도 하고요 이진 탐색이 동작할 수 있도록 보완된 효율적인 탐색이 가능한 자율 구조의 일종입니다. 이즘 탐색 트리에서 전체 노드에 대하여 이 부모 노드가 있을 때 왼쪽 자식 로드는 부모 로드보다 값이 작고 오른쪽 자식 노드는 부모 노드보다 값이 큰 형태를 가지도록 이진 탐색 트리를 구성합니다. 즉 이러한 특징이 유지될 수 있도록 트리를 구성한 것을 이진 탐색 트리라고 말합니다. 여기에서는 이진 탐색 트리를 어떻게 만들 수 있는지에 대한 내용은 생략을 하고 이와 같이 하나의 이진 탐색 트리가 있을 때 이진 탐색 트리에서 특정 데이터를 찾는 방법에 대해서 간략히 소개하겠습니다. 현재 오른쪽 그림은 대표적인 이진 탐색 필리의 예시인데요. 각각의 부모와 자식 관계를 확인해 보았을 때 모든 부모 로드는 왼쪽 자식 노드보다 그 값이 크고 모든 부모 로드는 오른쪽 자식 노드와 비교했을 때는 값이 작은 걸 확인할 수 있습니다. 값이 17인 이 노드 그리고 값이 48이 이 노드까지 마찬가지의 특징을 따르고 있는 걸 확인할 수 있습니다. 그러면 이러한 이진 탐색 트리서 어떻게 데이터를 조회할 수 있을까요. 한번 이진 탐색 트리가 이미 구성되어 있다고 가정하고 데이터를 조회하는 과정을 확인해 보겠습니다. 이때 이러한 이진 탐색 트에서 찾고자 하는 원소가 37이라고 가정해 보겠습니다. 이진 탐색 트리에서 데이터를 찾는 과정은 다음과 같은데요. 먼저 루트 노드부터 방문해서 탐색을 진행합니다. 현재 루트 노드의 값은 30이죠. 찾고자 하는 데이터의 값이 37이기 때문에 찾는 원소가 더 값이 큰 것을 확인할 수 있습니다. 그렇기 때문에 이때는 현재 확인하고 있는 노드에서 오른쪽을 방문할 수 있도록 하면 됩니다. 이진 탐색 트리의 특성상 오른쪽 자식 노드는 부모 노드보다 더 큰 값을 가지고 있기 때문에 오른쪽으로 이동한다고 보시면 되겠습니다. 두 번째 단계에서는 이와 같이 값이 48인 모드를 확인하는 걸 알 수 있습니다. 또한 이렇게 오른쪽으로 들어오는 순간 이 왼쪽 부분은 더 이상 확인할 필요가 없어집니다. 다시 말해서 탐색 과정을 진행하면서 이처럼 탐색 범위가 이상적인 경우 절반 가까이 줄어드는 걸 확인할 수 있습니다. 따라서 현재 확인하고 있는 값이 48인 노드와 비교했을 때 찾고자 하는 원소가 37이기 때문에 찾는 원소가 더 작으므로 이번에는 왼쪽을 방문할 수 있도록 합니다. 결과적으로 이 48번 노드를 기준으로 해서 이 오른쪽 부분은 더 이상 확인할 필요가 없어지게 되는 거고요 마찬가지로 다시 이렇게 현재 부모 노드인 값이 37인 노드를 확인할 수 있도록 합니다. 다만 현재 찾고자 하는 원소를 찾았기 때문에 여기에서 탐색을 종료합니다. 이러한 예시에서 확인할 수 있듯이 이진 탐색 트리는 이진 탐색이 가능한 형태로 탐색을 수행할 수 있도록 하기 위해서 보완된 트리 자료 구조의 일종으로서 이상적인 경우에 데이터를 탐색하는 경우 로그 n에 비례하는 연산이 소요될 수 있도록 합니다. 다만 그렇게 빠르게 탐색이 가능한 경우는 이와 같이 이진 탐색 트리가 왼쪽과 오른쪽에 대해서 균형이 잡혀 있는 형태로 트리가 구성되어 있을 때만 가능한 이야기이기 때문에 이상적인 경우에 그렇게 빠른 탐색이 가능하다는 점 기억해 주시면 좋습니다. 그래서 실제로는 트리 자료 구조를 활용한 굉장히 다양한 종류의 자료 구조가 존재하는데요. 이번 시간에는 간단히 트리 자료 구조의 전반적인 개념에 대해서 알아볼 예정이기 때문에 이와 같이 트리 자료 구조가 가질 수 있는 탐색 측면에서의 이점에 대해서 확인해 보았습니다. 이어서 트리 자료 구조에 포함되어 있는 모든 원소를 확인하고자 할 때 사용할 수 있는 가장 기본적인 방법인 트리의 수매에 대해서 알아보겠습니다. 트리의 수매는 트리 자료 구조에 포함된 노드를 특정한 방법으로 한 번씩 방문하여 확인하는 방법을 의미합니다. 이때 우리는 틀의 정보를 시각적으로 확인할 수 있기 때문에 우리가 트리 자료 구조를 실제 코드로 구현할 때 트리의 순매도 같이 구현해서 사용하는 경우가 많습니다. 이때 대표적인 트리 수매 방법은 바로 다음과 같이 세 가지가 존재하는데요. 전의 수매는 먼저 루트를 방문한 이후에 왼쪽과 오른쪽에 대해서 차례로 방문을 진행하는 방식을 의미하고요 중위순에는 왼쪽 자식을 먼저 방문한 뒤에 그다음에 루트를 방문하고 이어서 오른쪽 로드를 방문하는 방법을 의미합니다. 이어서 후이 수매 방식은 왼쪽 자식을 먼저 방문한 이후에 그다음에 오른쪽 자식을 방문한 뒤에 마지막으로 루트 모드를 방문하는 방식을 의미합니다. 한번 다음과 같이 트리 예제가 존재한다고 해볼게요 이때 전의 순회 중이순회 후이순회를 각각 수행한 결과는 바로 다음과 같습니다. 말씀드렸듯이 먼저 전의 순회 같은 경우는 루트를 먼저 출력한 이후에 왼쪽으로 들어가서 방문을 이어나간다고 했죠. 그래서 마찬가지로 이 비번 노드 또한 출력을 한 뒤에 다시 이렇게 왼쪽으로 들어가서 디번을 방문합니다. 이후에 다시 이렇게 b로 올라와서 이번에 다시 b 입장에서 오른쪽을 방문을 해야 되기 때문에 e가 출력되는 방식으로 방문이 진행되는 거고요 그래서 결과적으로 ab decf 순서대로 전의 순회 결과가 출력되는 걸 확인할 수 있고요 이어서 중위순회에서는 자기 자신을 방문하기 전에 이렇게 왼쪽 자식부터 확인을 진행하기 때문에 먼저 이렇게 비로 들어왔다가 다시 이렇게 b 또한 마찬가지로 뒤로 들어가서 결과적으로 뒤는 자식 로드가 없기 때문에 방문 처리를 수행하고 다시 이렇게 b로 올라와서 b또한 방문을 한 뒤에 다시 이렇게 2로 들어가서 2가 방문되고 다시 이렇게 e에서 b로 다시 이렇게 a로 거슬러 올라가서 다시 이렇게 처음. 호출했던 a가 방문되는 방식으로 진행되는 걸 확인할 수 있습니다. 그래서 전체 과정을 확인해 보시면 g beafcg 순서대로 중의 수매가 진행되고요 마지막으로 후유수매 같은 경우는 왼쪽을 방문하고 그다음 오른쪽을 방문한 뒤에 자기 자신을 방문하기 때문에 후에 손해를 진행했을 때는 먼저 a에서 b로 갔다가 다시 b에서 뒤로 갔다가 뒤를 방문 처리한 뒤에 다시 이렇게 b로 거슬러 올라가서 이를 방문한 뒤에 다시 이렇게 b로 돌아와서 b를 방문하는 걸 확인할 수 있습니다. 그래서 이런 식으로 방문을 진행하게 되면 d e b 그다음에 fgc 그다음 마지막으로 전체 트리에서 루트에 해당하는 이 에이버 노드가 방문되는 걸 확인할 수 있습니다. 그래서 트리의 손해를 실제로 구현한 예제는 바로 다음과 같은데요. 파이선으로 하나의 트리 구조를 현할 때는 이와 같이 하나의 노드 클래스를 정의할 수 있습니다. 그래서 자신의 데이터를 명시한 뒤에 레프트 노드와 라인 노드를 명시할 수 있도록 합니다. 그래서 간단하게 먼저 이와 같이 트리의 크기 즉 노드의 개수인 n이 들어오는 걸 확인할 수 있고 이어서 전체 트리는 간단히 딕셔너리를 이용해서 구현할 수 있는데요. 먼저 엔게이 데이터가 차례대로 들어오는 걸 확인할 수 있습니다. 이때 각각의 데이터는 이 트리에 담을 수 있도록 하고 각 노드는 자기 자신의 데이터와 그리고 레프트 노드 라인 노드가 각각 어떤 건지 담을 수 있도록 합니다. 그래서 결과적으로 데이터를 다 받은 뒤에 차례대로 전의 순회 중의회 호의 순회를 출력하는 걸 확인할 수 있고요 먼저 전의 순회 같은 경우는 앞서 설명드렸듯이 자기 자신 즉 자신의 데이터를 먼저 처리한 뒤에 이어서 왼쪽 로드와 오른쪽 로드를 방문하는 것을 확인할 수 있고요 이 중의 수에는 왼쪽을 먼저 방문한 뒤에 그다음에 자기 자신을 처리한 뒤에 오른쪽을 방문하는 걸 확인할 수 있고요 마지막으로 후유수에는 왼쪽과 오른쪽을 차례대로 방문한 뒤에 마지막으로 자기 자신을 처리하는 것을 확인할 수 있습니다. 따라서 아까 확인했던 코드를 그대로 붙여놓게 한 뒤에 코드를 실행해서 앞서 확인했던 그래프의 입력 예시를 그대로 붙여넣기 해보겠습니다. 실행 결과 다음과 같이 차례대로 전의 순회 중의 순회 그리고 후순의 결과가 출력되는 걸 확인할 수 있습니다. 이상으로 이번 시간에는 트리 자를 구조해 기본적인 개념과 트리의 순회 알고리즘에 대해 알아보는 시간을 가져보았습니다. 이번 1 이번 시간에는 별만 포드 알고리즘에 대해서 알아보겠습니다. 벨만 포드 알고리즘이 효과적으로 사용될 수 있는 상황은 응수 간성이 포함된 상황에 서의 최단 거리 문제입니다 한번 boj에 있는 타임머신 문제를 확인해 보겠습니다. 간단히 문제의 내용만 확인해 보시면 다음과 같은데요. m개의 도시가 있는 상황에서 m개의 방향 간선이 있는 걸 확인할 수 있습니다. 그래서 각각의 간선 정보 a에서 b로 가는 비용이 c다라는 형태로 들어오는 걸 확인할 수 있고요 다만 이때 이 c 즉 간선의 비용이 양수가 아닌 경우가 있다고 합니다. 이때 비용이 0인 경우에는 순간 이동을 하는 경우라고 할 수 있고 비용이 음수인 경우에는 타임머신을 이용해서 시간을 돌아갈 수 있는 경우라고 할 수 있습니다. 이때 1번 도시에서 출발해 나머지 도시로 가는 가장 빠른 시간을 구하는 프로그램을 작성하면 되는 걸 알 수 있는데요. 이때 도시의 개수는 최대 500개고 버스 노선 즉 간선의 개수 또한 최대 6천 개인 걸 확인할 수 있습니다. 이 문제는 어떻게 해결할 수 있을까요. 사실 이 문제의 조건은 간선이 양수가 아니라 음수가 될 수 있다는 조건을 제외하면 일반적인 다익스트라 알고리즘과 같은 조건입니다. 본 강의에서는 다익스트러 알고리즘을 이미 알고 있다고 가정하고 강의 내용을 진행하는데요. 앞서 언급했듯이 다익스트러 알고리즘 같은 경우는 모든 간승의 비용이 양수일 때 효과적으로 특정 노드에서 출발하여 다른 모든 노드까지의 최단 경로를 구할 수 있도록 해주는데요. 예를 들어서 아래와 같은 그래프가 있다고 했을 때 1번 노드에서 다른 모든 노드 각각으로 가기 위한 최소 비용은 어떻게 될까요. 이때 다익스테롤 알고리즘을 이용하면 바로 다음과 같이 각 노드로의 최단 거리를 구할 수 있습니다. 하지만 바로 다음과 같이 음수 간선이 포함되는 경우에는 어떻게 문제를 해결할 수 있을까요. 이제 아래 그래프를 확인해 보시면 이 5번 노드에서 2 노드로 가는 비용이 마이너스 2로 바뀐 걸 확인할 수 있습니다. 하지만 다행히도 이때도 여전히 차단거리를 구할 수 있습니다. 그냥 단순히 우리가 눈으로 확인해 보면 1번 노드에서 3번 노드까지 가는 비용은 2원이겠고 얜 더 이상 바뀌지 않을 겁니다. 또한 오버 노드까지 가는 비용은 3원이라고 할 수 있겠죠. 다만 이제 2번 노드 같은 경우는 그냥 바로 1에서 2로 가는 것보다 이렇게 1에서 3으로 갔다가 5로 갔다가 2로 가는 경우는 총 비용이 1원인 걸 확인할 수 있습니다. 이어서 이렇게 2번 노드까지 비용이 1원이었기 때문에 여기에서 이렇게 4로 가는 거는 3원이 되겠고요 다시 이렇게 3원에서 2원을 더해서 총 5원으로 6번 o데까지 갈 수 있다는 걸 우리는 단순히 눈으로 보아도 확인할 수 있습니다. 그래서 이러한 경우를 확인해 보시면은 단순히 음수 가능성이 있다고 해서 최소 비용을 결정 못하는 건 아니라는 걸 확인할 수 있습니다. 다만 음수 간선에 순환이 포함되는 경우에는 최소 비용을 특정한 값으로 결정할 수 없는 경우가 발생할 수 있는데요. 한번 아래 그래프를 확인해 보겠습니다. 현재 그래프에서는 5번 노드에서 이 노드로 가기 위한 비용이 마이너스 4로 명시되어 있는데요. 이 경우 이렇게 음수 간선의 사이클이 발생하는 걸 확인할 수 있습니다. 이때 이 사이클에 포함되어 있는 모든 간성에 대한 값을 더해 보시면 음수의 값을 가지는 걸 확인할 수 있는데요. 이제 이 경우에는 이 사이클을 반복적으로 도는 과정을 통해서 비용을 무한히 줄일 수 있습니다. 그래서 이와 같이 그래프 내에 음수 간선의 순환이 포함되어 있다면 최소 비용 즉 최단 거리가 음미 무한인 노드가 발생할 수 있습니다. 확인해 보시면 현재 그래프에서는 1번 노드에서 3번 노드로 가는 비용은 이 사이클을 무한히 반복하면 무한히 줄일 수 있기 때문에 값은 마이너스 무한이고요 2번 노드 또한 마찬가지고 5번 드 또한 마찬가지입니다. 이어서 4번 노드와 6번 노드는 이와 같이 음소 사이클에서부터 출발을 해서 이동할 수 있는 노드이기 때문에 마찬가지로 다 마이너스 무하의 값을 가지는 걸 확인할 수 있습니다. 즉 이렇게 특정한 그래프에서 최단 거리를 찾을 때 음수 순환이 포함되어 있는지를 체크하고자 한다면 어떤 알고리즘을 사용할 있을까요. 이때 우리는 벨만 포드 알고리즘을 사용할 수 있습니다. 일반적으로 음수 간선에 관하여 처단 경로 문제는 다음과 같이 분류할 수 있는데요. 모든 간선의 양수인 경우 그리고 음수 간선이 있는 경우가 있는데요. 이때는 또 음수 간선 순환은 없는 경우 그리고 음수 간선 순환이 있는 경우로 나눌 수 있습니다. 이때 벨만 코드 알고리즘은 이처럼 음의 강선이 포함된 상황에서도 사용할 수 있고 앞서 소개한 이런