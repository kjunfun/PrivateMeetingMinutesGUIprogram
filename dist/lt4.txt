먼저 풀어볼 문제는 1이 될 때까지라는 이름의 문제입니다. 같이 한 번 문제의 내용을 읽어보도록 할게요 어떠한 수 n이 1이 될 때까지 두 개의 과정 중 즉 두 개의 연산 중에 하나를 고르는 것을 이렇게 반복해서 n을 1로 만들고자 합니다. 연산을 확인해 보시면 n에서 1을 빼거나 혹은 n에서 k로 나누거나 이렇게 두 가지의 종류가 존재한다고 해요. 예를 들어서 이렇게 n이 17이고 k가 4라고 했을 때 먼저 이렇게 n에서 1을 빼가지고 n을 16으로 만듭니다. 이외 2번의 과정 n을 k로 나누는 과정을 두 번 수행하면 이 n은 1이 되겠죠. 그래서 결과적으로 단 3번만 연산을 수행해서 이 n을 이렇게 1로 만들 수가 있는 겁니다. 즉 이 문제는 n과 k가 주어졌을 때 n이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하면 되는 문제라고 할 수 있습니다. 이어서 문제의 조건을 확인해 보시면 이렇게 수행 시간 제한은 2초입니다. 이제 여기에서 n은 1 이상 10만 이하의 수고 이 케이는 이 이상 10만 이하의 수라고 합니다. 이때 각각 n과 케이는 자연수 형태로 양의 정수 형태로 주어진다고 하는 것을 확인할 수 있습니다. 이 문제는 어떻게 풀 수 있을까요. 바로 이 문제의 풀이 아이디어를 각자 고민해 보시고 코드를 작성하시면 되겠습니다. 그러면 이제 문제 풀이 방법에 대해서 설명하겠습니다. 본 문제의 해결 아이디어는 n에 대해서 가능한 많이 최대한 나누면 되는 겁니다. 우리는 n이 k로 나누어 떨어질 때 이 n을 k로 나눌 수가 있다고 했죠. 따라서 나누어 떨어진다면 그때마다 바로 나누기를 우선적으로 수행하면 되는 것입니다. 다시 말해서 하나의 변수에다가 이렇게 주어진 n 값을 저장을 한 다음에 매번 그 변수에 어떤 값이 담겨 있든 간에 나눌 수 있다면 나누고 그렇지 않다면 1을 빼는 방식을 반복하면 되겠죠. 이제 이러한 아이디어가 성립할 수 있는 이유는 n의 값을 줄일 때 이 이상의 수로 나누는 작업이 1을 빼는 작업보다 훨씬 빠르게 수를 줄일 수 있기 때문입니다. 예를 들어서 n이 100이라고 하고 케이가 5라고 해볼게요 이때 5로 나눈다면 한 번에 20이 되겠지만 1을 빼는 경우 a는 99로 얼마 줄어들지 않게 되는 겁니다. 그렇기 때문에 가능하면 최대한 나누는 작업을 수행하는 게 n을 빠르게 줄일 수 있겠죠. 다른 예시로 이렇게 n이 25고 k가 3일 때를 고려해 볼 수 있습니다. 이때 이렇게 초기 단계에 이 25인데 지금은 n이 3으로 나눠 떨어지지 않죠. 그렇기 때문에 이 n에서 1을 빼서 24로 만듭니다. 24는 k로 나누어 떨어지기 때문에 이제 이걸 3으로 나누어서 이렇게 n을 팔로 만들 수 있습니다. 또 이제 이어서 마찬가지로 이번에는 n이 3으로 나누어 떨어지지 않기 때문에 이렇게 1을 빼서 7로 만들 수가 있고 또 이어서 나누어 떨어지지 않기 때문에 또 1을 빼서 6으로 만듭니다. 이제 이번에는 3으로 나누어 떨어지죠 그래서 3으로 나누어주고 마지막으로 이렇게 1을 빼주게 되면 총 6번의 연산으로 n이 25 k가 3일 때 단 여섯 번의 연산으로 이 n을 1로 만들 수가 있는 겁니다. 그렇다면 이러한 아이디어가 정당한지에 대해서 한번 분석을 해보겠습니다. 우리의 아이디어는 가능하면 최대한 많이 나눌 수 있도록 하는 겁니다. 이게 항상 옵티멀한 솔루션을 보장할 수 있는 이유는 무엇일까요. 문제의 조건 이상 k가 항상 이 이상의 수이기 때문에 n이 아무리 큰수라고 해도 그냥 케이로 계속해서 나누기만 한다면 기하급수적으로 빠르게 줄일 수 있기 때문입니다. 즉 문제의 조건에 해당하는 n과 k에 대해서 항상 k로 나누는 것이 1을 빼는 것보다 빠르게 n을 줄일 수 있기 때문에 이러한 아이디어가 최적의 일을 보장할 수 있습니다. 또한 결과적으로 n은 항상 케이에 도달할 수 있습니다. 애초에 n이 양의 정수라는 가정 하에 n을 그냥 1씩 뺀다면 언젠가는 n이 1로 바뀌겠죠. 그렇기 때문에 n이 항상 1이 될 수 있다는 것 또한 자명합니다. 이어서 코드를 확인해볼게요 이렇게 두 개의 입력이 공백을 기준으로 해서 바로 입력이 되기 때문에 바로 입력받은 문자를 공백 기준으로 나눈 뒤에 맵 함수를 이용해서 각각 인트형 즉 정수로 바꾼 뒤에 n과 k에 넣은 것을 확인할 수 있습니다. 이제 바로 이렇게 반복문을 이용해서 n을 줄이는 걸 확인할 수 있는데요. 다만 이제 여기에서 한 가지 테크닉이 사용되는 걸 확인할 수 있습니다. 먼저 타겟이라는 변수에다가 n을 케이로 나눈 목에다가 다시 k를 곱한 값을 넣어줍니다. 이렇게 해주게 되면 만약에 n이 k로 나누어 떨어지지 않는다고 했을 때 가장 가까운 k로 나누어 떨어지는 수가 어떤 건지를 찾고자 할 때 사용할 수 있는 겁니다. 즉 우리는 n에서 1을 빼는 과정을 몇 번 반복해서 이 타겟이라는 값까지 만들 수가 있고 이 타겟이라는 값은 k로 나눠 떨어지는 수가 되겠습니다. 그래서 이렇게 타깃을 구한 뒤에 이어서 이 리졸트라는 변수는 우리가 총 연산을 수행하는 횟수라고 할 수 있는데 이렇게 이를 빼는 연산을 몇 번 수행할지 한 번에 계산해서 넣어주는 겁니다. 그래서 이렇게 1을 빼는 연산 횟수를 한 번에 더 해주고 이제 n이 탈겟이 될 수 있도록 만듭니다. 그다음 결과적으로 n이 k보다 작다면 이 반복문을 탈출할 수 있도록 하고 그렇지 않다면 n을 k로 나눌 수 있도록 하면 되는 것입니다. 이렇게 케이로 나누는 연산 한 번 수행하기 때문에 리졸트에다가 1을 더해주는 걸 확인할 수 있고요 그래서 결과적으로 n이 케이브가 작아졌을 때 탈출하게 되고 우리는 이제 n이 1보다 크다면 1이 될 수 있도록 만들기 위해서 남은 수에 대해서 1씩 빼는 연산을 이렇게 한 번에 또 계산할 수가 있는 겁니다. 다만 이제 이 문제 같은 경우는 문제의 조건을 확인해 보시면 이 n과 k가 10만 이하의 정수이기 때문에 사실 이렇게 작성하지 않고 그냥 매번 n을 확인해서 n이 k로 나누어 떨어진다면 나눠주고 그렇지 않다면 1을 빼주고 하는 방식으로 간단하게도 작성할 수가 있는데요. 다만 이렇게 작성해 주게 되면 이 반복문이 한 번 반복이 될 때마다 바로 이 k로 나뉘어지는 연산이 수행이 되기 때문에 반복 횟수에 따라서 기하 급수적으로 n이 빠르게 줄어들게 됩니다. 즉 시간 복잡도가 로그 시간 복잡도가 나올 수가 있는 겁니다. 그래서 이런 식으로 코드를 작성한 이유는 일종의 우리의 코드가 빨리 실행될 수 있도록 하는 테크닉을 가미했다고 볼 수 있는 것이며 이렇게 코드를 작성하게 되면 n과 k가 100억 1천억이 넘어가는 매우 큰 수라고 하더라도 로그 시간 복잡도록 빠르게 문제를 해결할 수 있습니다. 그래서 이렇게 문제 해결 과정에서는 이러한 테크닉이 가미된 소스 코드를 가져온 것입니다. 이어서 시플 플로도 마찬가지의 로직을 이용해서 문제를 해결할 수 있는데요. 이렇게 n과 k를 차례대로 입력을 받아주고요 이어서 와 문을 통해서 n이 k로 나누어 떨어지는 수가 될 때까지 1씩 뺄 수 있도록 만드는 거고 n이 k의 배수가 되었을 때 k로 나눌 수 있도록 합니다. 그래서 결과적으로 이렇게 반복문을 탈출한 이후에 최종적으로 na 1이 될 수 있을 때까지 1번 연산을 반복하면 되는 겁니다. 그래서 이렇게 소스 코드만 시불불 형식으로 작성이 되었고 실질적인 로직은 완전히 동일한 걸 확인할 수 있습니다. 그렇다면 자바 코드는 어떨까요. 자바 또한 마찬가지로 이렇게 공백을 기준으로 먼저 n과 k를 정수형 데이터로 입력을 받아서 조개를 해주고요 이어서 동일한 로직을 반복하는 걸 확인할 수 있습니다. 간단하게 1이 될 때까지 문제의 정답 코드를 확인해 보았고 실제 문제 풀이 코드까지 확인해 보았습니다. 이어서 풀어볼 문제는 곱하기 혹은 더하기 문제입니다. 바로 한번 문제를 읽어볼게요 각 자리가 숫자로만 이루어진 문자열 s가 주어졌을 때 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 곱하기 혹은 더하기 연산자를 넣어서 결과적으로 최대한 큰 수를 만들면 되는 겁니다. 단 여기에서 왼쪽부터 차례대로 연산자를 끼워 넣으면서 바로바로 연산이 수행된다고 가정합니다. 다시 말해 일반적인 대수학에서의 사칙 연산 우선순위와 다르게 모든 연산은 항상 왼쪽에서부터 순차적으로 이루어진다고 가정합니다. 예를 들어서 이렇게 029 84라는 문자열이 들어왔을 때 먼저 더 하고 그다음에 곱하고 그럼 이제 여기가 18이 되겠죠. 이어서 8을 곱하면 144가 될 겁니다. 이제 거기다가 4를 곱해서 576이 될 때가 가장 큰 수라는 걸 알 수 있습니다. 또한 가장 큰 수는 항상 20억 이하의 점수가 될 수 있도록 입력이 주어진다고 하네요. 이제 이렇게 입력이 주어지는 이유는 일반적인 프로그래밍 언어에서 정수 데이터를 위해 기본 인트형을 사용할 경우 약 21억 정도까지 값이 형성될 수 있기 때문에 그러한 점을 감안하고 이렇게 문제에서 최대값을 명시해 준 거라고 볼 수 있습니다. 예를 들어서 이렇게 모든 숫자가 다 9로 이루어지고 곱하기만 들어간다고 하면 20억보다 더 큰 수가 만들어질 수 있겠죠. 그렇기 때문에 이러한 조건도 주어진 거라고 예상할 수 있습니다. 사실 파이썬에서는 기본적으로 정수 데이터를 처리함에 있어서 수의 범위 제한이 없기 때문에 사실 이러한 조건이 없어도 파이썬에서는 큰 문제가 없을 테지만 찌뿔뿔 자바와 같은 다른 프로그래밍 언어를 사용하는 분들도 배려를 한 문제라고 보시면 되겠습니다. 그래서 이 문제는 수행 시간 제한이 1초고 메모리 제한은 128메가라고 합니다. 이 문제를 어떻게 해결할 수 있을까요. 마찬가지로 각자 개인적으로 문제를 풀어보시고 코드까지 작성을 해보세요. 그럼 이제 문제 해설을 진행하겠습니다. 이 문제 해결 아이디어는 바로 이전에 다루었던 문제와 유사합니다. 대부분의 경우 두 수에 대해서 연산을 수행할 때 더하기 연산보다는 이 곱하기 연산이 더 값을 크게 만듭니다. 예를 들어 5더하기 6은 11이지만 5 곱하기 6은 30이죠. 물론 이때도 예외가 있는데요. 만약에 더하는 두 수 중에서 하나라도 0 혹은 1인 경우에는 곱하기보다는 더하기를 수행하는 것이 더 효율적입니다. 예를 들어서 1 더하기 0은 1이지만 1 곱하기 0은 0이죠. 그렇기 때문에 두 수 중에서 하나라도 0이거나 1인 경우에는 더하기를 수행할 수 있도록 하면 되겠죠. 앞에서부터 차례대로 연산을 수행해 나가면서 값을 구해 나갈 때 연산을 수행하는 두 수 중에서 하나라도 1 이하인 경우에는 더 하고 두 수가 모두 2 이상인 경우에는 곱하면 정답 처리를 받을 수 있을 겁니다. 한번 파이썬 코드를 확인해 보겠습니다. 이렇게 숫자로만 구성된 하나의 문자열을 입력을 받은 다음에 가장 먼저 첫 번째 문자를 숫자로 변경해서 대입을 해줍니다. 이제 이어서 이 두 번째 숫자부터 차례대로 확인하면서 이제 매번 리저트 변수의 값과 새로 확인하는 값 사이에서 연산을 수행합니다. 두 수 중에서 하나라도 1 이하인 경우 즉 0 혹은 1인 경우 곱하기보다는 더하기를 수행하고 그렇지 않다면 곱하기를 수행하는 것을 반복하는 것을 확인할 수 있습니다. 즉 현재 상태에서 이러한 조건이 맞다면 더하기를 수행하고 그렇지 않다면 곱하기를 수행한다는 관점에서 전형적인 그리디 알고리즘이라고 표현할 수 있으며 파이썬뿐만 아니라 마찬가지로 시브블과 자바에서도 동일한 로직으로 문제를 풀 수 있습니다. 이렇게 심플 볼에서는 기본적으로 문자열 형태로 입력을 받은 뒤에 이제 이 값을 숫자로 바꾸고 싶다면 0에 해당하는 아스키 코드 값을 빼줌으로써 하나의 문자를 숫자로 바꾼 형태로 리졸트에 대입할 수 있습니다. 이제 이어서 마찬가지로 인덱스 1부터 즉 두 번째 숫자부터 차례대로 확인하면서 현재 리졸트 값과 새로 확인하는 이 넘 값과 매번 비교하면서 두 수 중에서 하나라도 1 이하인 경우에는 이렇게 더하기를 수행하고 그렇지 않을 때는 곱하기를 수행하는 걸 확인할 수 있습니다. 자바 또한 마찬가지의 로직으로 작성할 수 있고요 이 자바 같은 경우는 스트링 내부에 특정 문자에 접근하기 위해서 테렉털 엣이라는 메서드를 호출하는 것을 확인할 수 있습니다. 마찬가지로 시불과 동일하게 이 0을 문자로 표현한 것에 아스키 코드 값을 떼줌으로써 해당 첫 번째 문자의 숫자를 리졸티에 담을 수가 있고요 그래서 마찬가지의 로직으로 두 수에 대해서 매번 연산을 수행할 때 곱하기를 수행할지 더하기를 수행할지 이 조건에 따라서 결정하는 걸 확인할 수 있습니다. 이렇게 곱하기 5은 더하기 문제까지 풀어보았습니다. 이어서 무언가 길드 문제인데요. 이 문제 또한 바로 설명을 진행할게요 모험가 길드에는 n명의 험가가 존재하는데요. n명의 모험가는 각각 공포도를 가지고 있다고 합니다. 이때 이 n명의 모험가 중에서 여러 그룹을 만들려고 하는데요. 모험가 그룹을 결성할 때는 공포도가 x인 모험가는 반드시 x 명 이상으로 구성한 모험가 그룹에 참여할 수 있도록 해야 실제로 그룹이 결성되고 여행을 떠날 수 있다고 합니다. 이때 우리는 최대한 많은 수의 모험가 그룹을 만들고 싶습니다. 다시 말해 만들 수 있는 그룹 수의 최대값을 구하면 되는 문제라고 할 수 있습니다. 이 문제를 어떻게 풀 수 있을까요. 예를 들어 n이 5이고 각 무언가의 공포도는 이렇게 2 3 1 2 2라고 합니다. 이때 이 경우에는 첫 번째 그룹에 이 공포도가 1 2 3인 무언가를 한 명씩 넣고 그다음에 두 번째 그룹에는 공포도가 2인 남은 2명을 넣게 되면 총 2개의 그룹을 만들 수 있을 겁니다. 또한 문제의 조건상에 이렇게 몇 명의 모험가는 마을에 그대로 남아 있어도 되기 때문에 모든 무언가를 특정한 그룹에 넣을 필요는 없다고 하네요. 문제의 조건을 확인해 볼게요 시간 제한은 1초고요 그리고 메모리 제안은 128메가네요. 이렇게 첫째 줄에 모험가수 n이 주어지고 각 언가에 대한 공포도 값은 차례대로 공백을 기준으로 해서 주어지는 걸 확인할 수 있네요. 이 문제는 어떻게 풀 수 있을까요. 마찬가지로 여러분들 각자 한번 고민해 보시고 여러분들만의 코드로 작성해서 문제를 풀어보세요. 그럼 이제 이어서 해설을 진행하겠습니다. 이 문제는 오름차순 정렬 이후에 공포도가 낮은 무언가부터 하나씩 확인할 수 있도록 하는 게 첫 번째 과정입니다. 이렇게 일단 정렬히 수행해 볼게요 이렇게 오른 차선으로 정렬을 수행한 이후에 이제 여기에서 앞에서부터 공포도를 하나씩 확인하며 그룹을 결성할 수 있도록 할 건데요. 확인하면서 현재 그룹에 포함된 무언가의 수가 현재 확인하고 있는 공포도보다 크거나 같다면 바로 그룹을 결성해서 여행을 보낼 수 있도록 하면 되는 겁니다. 그래서 이렇게 하나씩 확인하면서 공포도가 1인 사람 그룹이 바로 결성되는 걸 확인할 수 있죠 그다음에 이제 이어서 이 두 번째를 확인하는데 모험가의 수는 한 명이지만 공포도가 2이기 때문에 그룹을 결성할 수 없을 겁니다. 이제 그다음에 이 세 번째 무언가를 확인했을 때 현재 그룹에 존재하는 사람이 2명이고 현재 공포도가 이렇게 2위기 때문에 아 이 두 명을 묶어서 하나의 그룹으로 만들면 되겠구나라고 판단할 수 있는 겁니다. 마찬가지로 이렇게 네 번째 모험가 다섯 번째 모험가는 매번 확인할 때 그 그룹에 포함되어 있는 모험가의 수가 현재 확인하고 있는 무언가의 공포도보다 더 작기 때문에 그룹을 결성할 수가 없습니다. 그래서 결과적으로 이러한 예시에서는 총 2개의 그룹이 만들어질 수 있으며 이러한 방법이 성립할 수 있는 이유는 공포도가 오른 차선으로 정렬이 되어 있기 때문에 항상 최소한의 모험가의 수만 호함에서 그룹을 결성할 수 있게 되기 때문입니다. 이제 한번 파이썬 코드부터 확인해 볼게요 이렇게 한 줄의 공백을 기준으로 해서 입력된 정수들을 정결할 수 있도록 하고요 총 그룹의 수는 이 리졸트에 담을 수 있도록 하고 그다음에 현재 그룹에 포함되는 무언가의 수는 이 카운트에 담을 수 있도록 합니다. 이 카운트 변수는 그룹이 결성될 때마다 다시 0으로 이렇게 업데이트하는 방식을 반복하면 되겠죠. 이제 정렬된 공포도를 하나씩 확인하면서 현재 그룹에 해당 무언가를 일단 포함을 시키는 거예요. 이제 현재 그룹에 포함되어 있는 무언가의 수가 현재 확인하고 있는 그 공포도보다 그거랑 같다면 그룹을 결성해서 보낼 수가 있겠죠. 그래서 만약에 그룹이 결성되는 경우 리졸트에 이를 추가해서 그룹이 새롭게 결성되었다는 걸 확인할 수 있고 또한 이제 다음 그룹을 확인하기 위해 이 카운트 값을 0으로 초기화할 수 있습니다. 그래서 이러한 과정을 거친 뒤에 결과적으로 리졸트 값을 출력하면 정답이 될 수 있겠죠. 마찬가지로 시불 불에서도 동일한 로직으로 문제를 풀 수 있습니다. 일반적으로 파이썬에서 리스트를 사용한다면 시불불에서는 벡터 라이브러리를 사용합니다. 그래서 차례대로 이렇게 변수를 입력받은 뒤에 이 팩터에 담아줄 수 있도록 하고 오름차순 정렬을 수행합니다. 이제 이어서 하나씩 원소를 확인하면서 현재 그룹에 포함된 무언가의 수가 현재 확인하고 있는 공포도 이상이라면 그룹을 결성하는 방식으로 마찬가지의 로직으로 문제를 풀고 있는 걸 확인할 수 있습니다. 바 또한 마찬가지의 로직으로 작성할 수 있는데요. 이 자바에서는 다수의 데이터를 넣기 위한 자료 구조로 이 어의 리스트를 사용할 수 있고 어레이 리스트는 이런 식으로 이 컬렉션 라이브러리의 솔트 메서드를 이용해서 어레이 리스트에 담겨 있는 데이터를 간단하게 정렬할 수가 있고요 이제 마찬가지의 로직은 동일하게 작성되어 있는 걸 확인할 수 있습니다. 이상으로 모험과 길드 문제까지 풀어보았습니다.